{
    "docs": [
        {
            "location": "/", 
            "text": "API Star\n\n\nA smart Web API framework, designed for Python 3.\n\n\n\n\n\nCommunity:\n \nhttps://discuss.apistar.org/\n \ud83e\udd14 \ud83d\udcad \ud83e\udd13 \ud83d\udcac \ud83d\ude0e\n\n\nRepository\n: \nhttps://github.com/encode/apistar\n \ud83d\udcbb\n\n\n\n\nQuickstart\n\n\nInstall API Star:\n\n\n$ pip3 install apistar\n\n\n\n\nCreate a new project in \napp.py\n:\n\n\nfrom apistar import App, Route\n\n\ndef welcome(name=None):\n    if name is None:\n        return {'message': 'Welcome to API Star!'}\n    return {'message': 'Welcome to API Star, %s!' % name}\n\n\nroutes = [\n    Route('/', method='GET', handler=welcome),\n]\n\napp = App(routes=routes)\n\n\nif __name__ == '__main__':\n    app.serve('127.0.0.1', 5000, debug=True)", 
            "title": "Home"
        }, 
        {
            "location": "/#api-star", 
            "text": "A smart Web API framework, designed for Python 3.   Community:   https://discuss.apistar.org/  \ud83e\udd14 \ud83d\udcad \ud83e\udd13 \ud83d\udcac \ud83d\ude0e  Repository :  https://github.com/encode/apistar  \ud83d\udcbb", 
            "title": "API Star"
        }, 
        {
            "location": "/#quickstart", 
            "text": "Install API Star:  $ pip3 install apistar  Create a new project in  app.py :  from apistar import App, Route\n\n\ndef welcome(name=None):\n    if name is None:\n        return {'message': 'Welcome to API Star!'}\n    return {'message': 'Welcome to API Star, %s!' % name}\n\n\nroutes = [\n    Route('/', method='GET', handler=welcome),\n]\n\napp = App(routes=routes)\n\n\nif __name__ == '__main__':\n    app.serve('127.0.0.1', 5000, debug=True)", 
            "title": "Quickstart"
        }, 
        {
            "location": "/api-guide/applications/", 
            "text": "Applications\n\n\nThe first thing you'll always need to do when creating a new API Star service\nis to create an application instance.\n\n\nHere's an example that just returns a simple HTML homepage:\n\n\nfrom apistar import App, Route\n\n\ndef homepage() -\n str:\n    return '\nhtml\nbody\nh1\nHomepage\n/h1\n/body\n/html\n'\n\n\nroutes = [\n    Route('/', method='GET', handler=homepage),\n]\n\napp = App(routes=routes)\n\n\n\n\nSync or ASync\n\n\nAPI Star supports both multi-threaded (WSGI) and asyncio (ASGI) modes of operation.\n\n\nThe Python ecosystem currently has far more support for multi-threaded concurrency.\nMost existing database adapters, ORMs, and other networking components are\ndesigned to work within this context. If you're not sure which of the two modes\nyou want, then you probably want to use the standard \nApp\n instance.\n\n\nFor IO-bound web services where you need particularly high throughput\nyou might want to choose the asyncio mode. If you do so then you'll need to\nmake sure that you're only ever making network requests or disk access using\nasync operations, and packages designed to work with asyncio.\n\n\nFor an asyncio-based application, you should use the \nASyncApp\n class.\n\n\nOnce you're using \nASyncApp\n you'll be able to route to either standard\nfunctions, or to \nasync\n functions.\n\n\nfrom apistar import ASyncApp, Route\n\nasync def hello_world() -\n dict:\n    # We can perform some network I/O here, asyncronously.\n    return {'hello': 'async'}\n\nroutes = [\n    Route('/', method='GET', handler=hello_world)\n]\n\napp = ASyncApp(routes=routes)\n\n\n\n\nThe development server\n\n\nTo run the development server, you should include something like the following\nin your \napp.py\n module.\n\n\nif __name__ == '__main__':\n    app.serve('127.0.0.1', 5000, debug=True)\n\n\n\n\nIf \ndebug\n is set to \nTrue\n, then the interactive debugger will be triggered on exceptions.\nIf \ndebug\n is not set, then exceptions will result in a 500 Server Error.\n\n\nYou should only use \napp.serve()\n for local development. See the \ndeployment documentation\n for information on running API Star in production.", 
            "title": "Applications"
        }, 
        {
            "location": "/api-guide/applications/#applications", 
            "text": "The first thing you'll always need to do when creating a new API Star service\nis to create an application instance.  Here's an example that just returns a simple HTML homepage:  from apistar import App, Route\n\n\ndef homepage() -  str:\n    return ' html body h1 Homepage /h1 /body /html '\n\n\nroutes = [\n    Route('/', method='GET', handler=homepage),\n]\n\napp = App(routes=routes)", 
            "title": "Applications"
        }, 
        {
            "location": "/api-guide/applications/#sync-or-async", 
            "text": "API Star supports both multi-threaded (WSGI) and asyncio (ASGI) modes of operation.  The Python ecosystem currently has far more support for multi-threaded concurrency.\nMost existing database adapters, ORMs, and other networking components are\ndesigned to work within this context. If you're not sure which of the two modes\nyou want, then you probably want to use the standard  App  instance.  For IO-bound web services where you need particularly high throughput\nyou might want to choose the asyncio mode. If you do so then you'll need to\nmake sure that you're only ever making network requests or disk access using\nasync operations, and packages designed to work with asyncio.  For an asyncio-based application, you should use the  ASyncApp  class.  Once you're using  ASyncApp  you'll be able to route to either standard\nfunctions, or to  async  functions.  from apistar import ASyncApp, Route\n\nasync def hello_world() -  dict:\n    # We can perform some network I/O here, asyncronously.\n    return {'hello': 'async'}\n\nroutes = [\n    Route('/', method='GET', handler=hello_world)\n]\n\napp = ASyncApp(routes=routes)", 
            "title": "Sync or ASync"
        }, 
        {
            "location": "/api-guide/applications/#the-development-server", 
            "text": "To run the development server, you should include something like the following\nin your  app.py  module.  if __name__ == '__main__':\n    app.serve('127.0.0.1', 5000, debug=True)  If  debug  is set to  True , then the interactive debugger will be triggered on exceptions.\nIf  debug  is not set, then exceptions will result in a 500 Server Error.  You should only use  app.serve()  for local development. See the  deployment documentation  for information on running API Star in production.", 
            "title": "The development server"
        }, 
        {
            "location": "/api-guide/requests-and-responses/", 
            "text": "Requests and Responses\n\n\nRequests\n\n\nTo access the incoming HTTP request, use the \nhttp.Request\n class as an\nannotation on the handler function.\n\n\nfrom apistar import http\n\n\ndef echo_request_info(request: http.Request) -\n dict:\n    return {\n        'method': request.method,\n        'url': request.url,\n        'headers': dict(request.headers),\n        'body': request.body.decode('utf-8')\n    }\n\n\n\n\nAPI Star allows you to dynamically inject various other information about the\nincoming request into your views using type annotation.\n\n\nfrom apistar import http\n\n\ndef echo_query_params(query_params: http.QueryParams) -\n dict:\n    return {\n        'params': dict(query_params)\n    }\n\ndef echo_user_agent(user_agent: http.Header) -\n dict:\n    return {\n        'user-agent': user_agent\n    }\n\n\n\n\nSome of the components you might use most often:\n\n\n\n\n\n\n\n\nComponent\n\n\nDescription\n\n\n\n\n\n\n\n\n\n\nhttp.Request\n\n\nThe HTTP request. Includes \n.method\n, \n.url\n, and \n.headers\n attributes.\n\n\n\n\n\n\nhttp.Headers\n\n\nThe request headers, returned as a dictionary-like object.\n\n\n\n\n\n\nhttp.Header\n\n\nLookup a single request header, corresponding to the argument name.\nReturns a string or \nNone\n.\n\n\n\n\n\n\nhttp.QueryParams\n\n\nThe request query parameters, returned as a dictionary-like object.\n\n\n\n\n\n\nhttp.QueryParam\n\n\nLookup a single query parameter, corresponding to the argument name.\nReturns a string or \nNone\n.\n\n\n\n\n\n\nhttp.Body\n\n\nThe request body, as a bytestring.\n\n\n\n\n\n\n\n\nResponses\n\n\nBy default API star uses HTML responses for handlers that return strings,\nand JSON responses for anything else.\n\n\ndef hello_world() -\n dict:\n    return {'text': 'Hello, world!'}\n\n\n\n\nFor more control over the response use the \nJSONResponse\n and\n\nHTMLResponse\n classes.\n\n\nfrom apistar import http\n\n\ndef hello_world(accept_language: http.Header) -\n http.JSONResponse:\n    if 'de' in accept_language:\n        data = {'text': 'Hallo, Welt!'}\n    else:\n        data = {'text': 'Hello, world!'}\n    headers = {'Vary': 'Accept-Language'}\n    return http.JSONResponse(data, status_code=200, headers=headers)\n\n\n\n\nFor other content types, use a \nResponse\n class, and set the content-type\nheader explicitly.\n\n\nfrom apistar import http\n\n\ndef hello_world() -\n http.Response:\n    content = 'Hello, world!'\n    headers = {'Content-Type': 'text/plain'}\n    return http.Response(content, headers=headers)", 
            "title": "Requests and Responses"
        }, 
        {
            "location": "/api-guide/requests-and-responses/#requests-and-responses", 
            "text": "", 
            "title": "Requests and Responses"
        }, 
        {
            "location": "/api-guide/requests-and-responses/#requests", 
            "text": "To access the incoming HTTP request, use the  http.Request  class as an\nannotation on the handler function.  from apistar import http\n\n\ndef echo_request_info(request: http.Request) -  dict:\n    return {\n        'method': request.method,\n        'url': request.url,\n        'headers': dict(request.headers),\n        'body': request.body.decode('utf-8')\n    }  API Star allows you to dynamically inject various other information about the\nincoming request into your views using type annotation.  from apistar import http\n\n\ndef echo_query_params(query_params: http.QueryParams) -  dict:\n    return {\n        'params': dict(query_params)\n    }\n\ndef echo_user_agent(user_agent: http.Header) -  dict:\n    return {\n        'user-agent': user_agent\n    }  Some of the components you might use most often:     Component  Description      http.Request  The HTTP request. Includes  .method ,  .url , and  .headers  attributes.    http.Headers  The request headers, returned as a dictionary-like object.    http.Header  Lookup a single request header, corresponding to the argument name. Returns a string or  None .    http.QueryParams  The request query parameters, returned as a dictionary-like object.    http.QueryParam  Lookup a single query parameter, corresponding to the argument name. Returns a string or  None .    http.Body  The request body, as a bytestring.", 
            "title": "Requests"
        }, 
        {
            "location": "/api-guide/requests-and-responses/#responses", 
            "text": "By default API star uses HTML responses for handlers that return strings,\nand JSON responses for anything else.  def hello_world() -  dict:\n    return {'text': 'Hello, world!'}  For more control over the response use the  JSONResponse  and HTMLResponse  classes.  from apistar import http\n\n\ndef hello_world(accept_language: http.Header) -  http.JSONResponse:\n    if 'de' in accept_language:\n        data = {'text': 'Hallo, Welt!'}\n    else:\n        data = {'text': 'Hello, world!'}\n    headers = {'Vary': 'Accept-Language'}\n    return http.JSONResponse(data, status_code=200, headers=headers)  For other content types, use a  Response  class, and set the content-type\nheader explicitly.  from apistar import http\n\n\ndef hello_world() -  http.Response:\n    content = 'Hello, world!'\n    headers = {'Content-Type': 'text/plain'}\n    return http.Response(content, headers=headers)", 
            "title": "Responses"
        }, 
        {
            "location": "/api-guide/routing/", 
            "text": "Routing\n\n\nUse \n{curly_braces}\n in your URL conf to include a URL path parameter.\n\n\nfrom apistar import App, Route\n\n\ndef echo_username(username: str) -\n dict:\n    return {'message': 'Welcome, %s!' % username}\n\n\nroutes = [\n    Route('/users/{username}/', method='GET', handler=echo_username)\n]\n\napp = App(routes=routes)\n\n\n\n\nUse type annotation on a handler to match integers or floats in the URL string.\n\n\nfrom apistar import App, Route, exceptions\n\n\nUSERS = {1: 'hazel', 2: 'james', 3: 'ana'}\n\ndef echo_username(user_id: int) -\n dict:\n    if user_id not in USERS:\n        raise exceptions.NotFound()\n    return {'message': 'Welcome, %s!' % USERS[user_id]}\n\nroutes = [\n    Route('/users/{user_id}/', method='GET', handler=echo_username)\n]\n\napp = App(routes=routes)\n\n\n\n\nIf you want to capture a complete URL path parameter \nincluding any \n/\n\ncharacters\n then use \n{+curly_braces}\n.\n\n\nroutes = [\n    Route('/static/{+path}', method='GET', handler=serve_file)\n]\n\napp = App(routes=routes)\n\n\n\n\nBuilding URLS\n\n\nYou can generate URL strings that match your routing configuration by using \napp.reverse_url(name, **parameters)\n.\n\n\nfrom apistar import App, Route, exceptions\n\n\nUSERS = {1: 'hazel', 2: 'james', 3: 'ana'}\n\ndef list_users(app: App) -\n list:\n    return [\n        {\n            'username': username,\n            'url': app.reverse_url('get_user', user_id=user_id)\n        } for user_id, username in USERS.items()\n    ]\n\ndef get_user(app: App, user_id: int) -\n dict:\n    if user_id not in USERS:\n        raise exceptions.NotFound()\n    return {\n        'username': USERS[user_id],\n        'url': app.reverse_url('get_user', user_id=user_id)\n    }\n\nroutes = [\n    Route('/users/', method='GET', handler=list_users),\n    Route('/users/{user_id}/', method='GET', handler=get_user)\n]\n\napp = App(routes=routes)\n\n\n\n\nRouting in larger projects\n\n\nIn many projects you may want to split your routing into different sections.\nUse \nInclude\n to add a list of routes under a single URL prefix.\n\n\nmyproject/users.py\n\n\nfrom apistar import App, Route, exceptions\n\n\nUSERS = {1: 'hazel', 2: 'james', 3: 'ana'}\n\ndef list_users(app: App) -\n list:\n    return [\n        {\n            'username': username,\n            'url': app.reverse_url('users:get_user', user_id=user_id)\n        } for user_id, username in USERS.items()\n    ]\n\ndef get_user(app: App, user_id: int) -\n dict:\n    if user_id not in USERS:\n        raise exceptions.NotFound()\n    return {\n        'username': USERS[user_id],\n        'url': app.reverse_url('users:get_user', user_id=user_id)\n    }\n\nroutes = [\n    Route('/', method='GET', handler=list_users),\n    Route('/{user_id}', method='GET', handler=get_user),\n]\n\n\n\n\napp.py:\n\n\nfrom apistar import App, Include\nfrom myproject import users\n\nroutes = [\n    Include('/users', name='users', routes=users.routes),\n    ...\n]\n\napp = App(routes=routes)", 
            "title": "Routing"
        }, 
        {
            "location": "/api-guide/routing/#routing", 
            "text": "Use  {curly_braces}  in your URL conf to include a URL path parameter.  from apistar import App, Route\n\n\ndef echo_username(username: str) -  dict:\n    return {'message': 'Welcome, %s!' % username}\n\n\nroutes = [\n    Route('/users/{username}/', method='GET', handler=echo_username)\n]\n\napp = App(routes=routes)  Use type annotation on a handler to match integers or floats in the URL string.  from apistar import App, Route, exceptions\n\n\nUSERS = {1: 'hazel', 2: 'james', 3: 'ana'}\n\ndef echo_username(user_id: int) -  dict:\n    if user_id not in USERS:\n        raise exceptions.NotFound()\n    return {'message': 'Welcome, %s!' % USERS[user_id]}\n\nroutes = [\n    Route('/users/{user_id}/', method='GET', handler=echo_username)\n]\n\napp = App(routes=routes)  If you want to capture a complete URL path parameter  including any  / \ncharacters  then use  {+curly_braces} .  routes = [\n    Route('/static/{+path}', method='GET', handler=serve_file)\n]\n\napp = App(routes=routes)", 
            "title": "Routing"
        }, 
        {
            "location": "/api-guide/routing/#building-urls", 
            "text": "You can generate URL strings that match your routing configuration by using  app.reverse_url(name, **parameters) .  from apistar import App, Route, exceptions\n\n\nUSERS = {1: 'hazel', 2: 'james', 3: 'ana'}\n\ndef list_users(app: App) -  list:\n    return [\n        {\n            'username': username,\n            'url': app.reverse_url('get_user', user_id=user_id)\n        } for user_id, username in USERS.items()\n    ]\n\ndef get_user(app: App, user_id: int) -  dict:\n    if user_id not in USERS:\n        raise exceptions.NotFound()\n    return {\n        'username': USERS[user_id],\n        'url': app.reverse_url('get_user', user_id=user_id)\n    }\n\nroutes = [\n    Route('/users/', method='GET', handler=list_users),\n    Route('/users/{user_id}/', method='GET', handler=get_user)\n]\n\napp = App(routes=routes)", 
            "title": "Building URLS"
        }, 
        {
            "location": "/api-guide/routing/#routing-in-larger-projects", 
            "text": "In many projects you may want to split your routing into different sections.\nUse  Include  to add a list of routes under a single URL prefix.  myproject/users.py  from apistar import App, Route, exceptions\n\n\nUSERS = {1: 'hazel', 2: 'james', 3: 'ana'}\n\ndef list_users(app: App) -  list:\n    return [\n        {\n            'username': username,\n            'url': app.reverse_url('users:get_user', user_id=user_id)\n        } for user_id, username in USERS.items()\n    ]\n\ndef get_user(app: App, user_id: int) -  dict:\n    if user_id not in USERS:\n        raise exceptions.NotFound()\n    return {\n        'username': USERS[user_id],\n        'url': app.reverse_url('users:get_user', user_id=user_id)\n    }\n\nroutes = [\n    Route('/', method='GET', handler=list_users),\n    Route('/{user_id}', method='GET', handler=get_user),\n]  app.py:  from apistar import App, Include\nfrom myproject import users\n\nroutes = [\n    Include('/users', name='users', routes=users.routes),\n    ...\n]\n\napp = App(routes=routes)", 
            "title": "Routing in larger projects"
        }, 
        {
            "location": "/api-guide/templates/", 
            "text": "Templates\n\n\nAPI Star is particularly designed around building APIs, but is equally\ncapable of being used to build web applications.\n\n\nConfiguration\n\n\nYou'll need to install \njinja2\n to use the default template backend.\n\n\nTo include templates in your application, create a directory to contain the templates,\nand include it with the \ntemplate_dir\n argument when instantiating the app.\n\n\nimport os\n\nBASE_DIR = os.path.dirname(__file__)\nTEMPLATE_DIR = os.path.join(BASE_DIR, 'templates')\n\n...\n\napp = App(routes=routes, template_dir=TEMPLATE_DIR)\n\n\n\n\nRendering templates\n\n\nTo render a template, use \napp.render_template(template_name, **context)\n.\n\n\ntemplates/index.html\n:\n\n\nhtml\n\n    \nbody\n\n        {% if name %}\n        \nh1\nHello, {{ name }}!\n/h1\n\n        {% else %}\n        \nh1\nHello!\n/h1\n\n        {% endif %}\n    \n/body\n\n\n/html\n\n\n\n\n\napp.py\n:\n\n\nimport os\nfrom apistar import App, Route\n\n\nBASE_DIR = os.path.dirname(__file__)\nTEMPLATE_DIR = os.path.join(BASE_DIR, 'templates')\n\n\ndef welcome(app: App, name=None):\n    return app.render_template('index.html', name=name)\n\nroutes = [\n    Route('/', method='GET', handler=welcome),\n]\n\napp = App(routes=routes, template_dir=TEMPLATE_DIR)\n\n\nif __name__ == '__main__':\n    app.serve('127.0.0.1', 8080, use_debugger=True)\n\n\n\n\nYou can configure where templates are served from by using the \ntemplate_dir\n\nargument when instantiating an application.", 
            "title": "Templates"
        }, 
        {
            "location": "/api-guide/templates/#templates", 
            "text": "API Star is particularly designed around building APIs, but is equally\ncapable of being used to build web applications.", 
            "title": "Templates"
        }, 
        {
            "location": "/api-guide/templates/#configuration", 
            "text": "You'll need to install  jinja2  to use the default template backend.  To include templates in your application, create a directory to contain the templates,\nand include it with the  template_dir  argument when instantiating the app.  import os\n\nBASE_DIR = os.path.dirname(__file__)\nTEMPLATE_DIR = os.path.join(BASE_DIR, 'templates')\n\n...\n\napp = App(routes=routes, template_dir=TEMPLATE_DIR)", 
            "title": "Configuration"
        }, 
        {
            "location": "/api-guide/templates/#rendering-templates", 
            "text": "To render a template, use  app.render_template(template_name, **context) .  templates/index.html :  html \n     body \n        {% if name %}\n         h1 Hello, {{ name }}! /h1 \n        {% else %}\n         h1 Hello! /h1 \n        {% endif %}\n     /body  /html   app.py :  import os\nfrom apistar import App, Route\n\n\nBASE_DIR = os.path.dirname(__file__)\nTEMPLATE_DIR = os.path.join(BASE_DIR, 'templates')\n\n\ndef welcome(app: App, name=None):\n    return app.render_template('index.html', name=name)\n\nroutes = [\n    Route('/', method='GET', handler=welcome),\n]\n\napp = App(routes=routes, template_dir=TEMPLATE_DIR)\n\n\nif __name__ == '__main__':\n    app.serve('127.0.0.1', 8080, use_debugger=True)  You can configure where templates are served from by using the  template_dir \nargument when instantiating an application.", 
            "title": "Rendering templates"
        }, 
        {
            "location": "/api-guide/static-files/", 
            "text": "Static Files\n\n\nYou'll need to install \nwhitenoise\n to use the default static files backend.\nIf you're using \nASyncApp\n you'll also need to install \naiofiles\n.\n\n\nTo include static files in your application, create a directory to contain the static files,\nand include it with the \nstatic_dir\n argument when instantiating the app.\n\n\nimport os\n\nBASE_DIR = os.path.dirname(__file__)\nSTATIC_DIR = os.path.join(BASE_DIR, 'static')\n\n...\n\napp = App(routes=routes, static_dir=STATIC_DIR)\n\n\n\n\nThe default behavior is to serve static files from the URL prefix \n/static/\n.\nYou can modify this by also including a \nstatic_url\n argument.", 
            "title": "Static Files"
        }, 
        {
            "location": "/api-guide/static-files/#static-files", 
            "text": "You'll need to install  whitenoise  to use the default static files backend.\nIf you're using  ASyncApp  you'll also need to install  aiofiles .  To include static files in your application, create a directory to contain the static files,\nand include it with the  static_dir  argument when instantiating the app.  import os\n\nBASE_DIR = os.path.dirname(__file__)\nSTATIC_DIR = os.path.join(BASE_DIR, 'static')\n\n...\n\napp = App(routes=routes, static_dir=STATIC_DIR)  The default behavior is to serve static files from the URL prefix  /static/ .\nYou can modify this by also including a  static_url  argument.", 
            "title": "Static Files"
        }, 
        {
            "location": "/api-guide/type-system/", 
            "text": "Type System\n\n\nAPI Star comes with a type system that allows you to express constraints on the\nexpected inputs and outputs of your interface.\n\n\nHere\u2019s a quick example of what the type system in API Star looks like:\n\n\nfrom apistar import types, validators\n\n\nclass Product(types.Type):\n    name = validators.String(max_length=100)\n    rating = validators.Integer(minimum=1, maximum=5)\n    in_stock = validators.Boolean(default=False)\n    size = validators.String(enum=['small', 'medium', 'large'])\n\n\n\n\nYou can use the type system both for validation of incoming request data, and\nfor serializing outgoing response data.\n\n\nInvalid data will result in a \nValidationError\n being raised.\n\n\n data = {'name': 't-shirt', 'size': 'big'}\n\n product = Product(data)\napistar.exceptions.ValidationError: {'rating': 'This field is required.', 'size': 'Must be a valid choice.'}\n\n\n\n\nValid data will instantiate a new \nType\n instance.\n\n\n data = {'name': 't-shirt', 'rating': 4, 'size': 'large'}\n\n product = Product(data)\n\nProduct(name='t-shirt', rating=4, in_stock=False, size='large')\n\n\n\n\n\nYou can access the values on a \nType\n instance as attributes.\n\n\n product.name\n't-shirt'\n\n\n\n\nOr treat a \nType\n as a dictionary-like object.\n\n\n product['rating']:\n4\n\n dict(product)\n{'name': 't-shirt', 'rating': 4, 'in_stock': False, 'size': 'large'}\n\n\n\n\nNested types\n\n\nYou can include \nType\n classes as fields on other \nType\n classes, like so:\n\n\nclass Location(types.Type):\n    latitude = validators.Number(maximum=90.0, minimum=-90.0)\n    longitude = validators.Number(maximum=180.0, minimum=-180.0)\n\n\nclass Event(types.Type):\n    location = Location\n    name = validators.String(max_length=100)\n\n\n\n\nValidation\n\n\nYou can use API Star \nType\n classes as annotations inside your handler functions.\n\n\nWhen you do so, validation will be handled automatically prior to running\nthe handler function. The type information will also be made available\nin the application's API Schema.\n\n\ndef create_product(product: Product):\n    # Save a new product record in the database.\n    ...\n\nroutes = [\n    Route('/create_product/', method='POST', handler=create_product)\n]\n\n\n\n\nSerialization\n\n\nYou may also want to using the type system for data serialization,\nand include the type as a return annotation on handler functions.\n\n\nAgain, doing so will expose the type information to the application's\nAPI Schema, and will help ensure that the information your system\nreturns matches its documented return types.\n\n\nimport typing\n\n\ndef list_products() -\n typing.List[Product]:\n    queryset = ...  # Query returning products from a data store.\n    return [Product(record) for record in queryset]\n\n\n\n\nIncluding additional validation\n\n\nIf you have validation rules that cannot be expressed with the default types,\nyou can include these by subclass the \n__init__\n method on the class.\n\n\nThis method should return the validated data, or raise a \nValidationError\n.\n\n\nfrom apistar import exceptions, types, validators\n\n\nclass Organisation(types.Type):\n    is_premium = validators.Boolean()\n    expiry_date = validators.Date(allow_null=True)\n\n    def __init__(self, *args, **kwargs):\n        value = super().__init__(*args, **kwargs)\n        if value.is_premium and value.expiry_date is not None:\n            message = 'premium organisations should not have any expiry_date set.'\n            raise exceptions.ValidationError(message)\n        return value\n\n\n\n\nAPI Reference\n\n\nThe following typesystem types are supported:\n\n\nString\n\n\nValidates string data.\n\n\n\n\ndefault\n - A default to be used if a field using this typesystem is missing from a parent \nType\n.\n\n\ntitle\n - A title to use in API schemas and documentation.\n\n\ndescription\n - A description to use in API schemas and documentation.\n\n\nmax_length\n - A maximum valid length for the data.\n\n\nmin_length\n - A minimum valid length for the data.\n\n\npattern\n - A string value, giving a regular expression that the data must match.\n\n\nenum\n - A list of valid strings that the input must match against.\n\n\nformat\n - An identifier indicating a complex datatype with a string representation. For example \n\"date\"\n, to represent an ISO 8601 formatted date string.\n\n\nallow_null\n - Indicates if \nNone\n should be considered a valid value. Defaults to \nFalse\n.\n\n\n\n\nNumber\n\n\nValidates numeric data.\n\n\n\n\ndefault\n - A default to be used if a field using this typesystem is missing from a parent \nType\n.\n\n\ntitle\n - A title to use in API schemas and documentation.\n\n\ndescription\n - A description to use in API schemas and documentation.\n\n\nmaximum\n - A float representing the maximum valid value for the data.\n\n\nminimum\n - A float representing the minimum valid value for the data.\n\n\nexclusive_maximum\n - \nTrue\n for an exclusive maximum limit. Defaults to \nFalse\n.\n\n\nexclusive_minimum\n - \nTrue\n for an exclusive minimum limit. Defaults to \nFalse\n.\n\n\nmultiple_of\n - A float that the data must be strictly divisible by, in order to be valid.\n\n\nenum\n - A list of valid numbers that the input must match against.\n\n\nallow_null\n - Indicates if \nNone\n should be considered a valid value. Defaults to \nFalse\n.\n\n\n\n\nInteger\n\n\nValidates integer data.\n\n\n\n\ndefault\n - A default to be used if a field using this typesystem is missing from a parent \nType\n.\n\n\ntitle\n - A title to use in API schemas and documentation.\n\n\ndescription\n - A description to use in API schemas and documentation.\n\n\nmaximum\n - An int representing the maximum valid value for the data.\n\n\nminimum\n - An int representing the minimum valid value for the data.\n\n\nexclusive_maximum\n - \nTrue\n for an exclusive maximum limit. Defaults to \nFalse\n.\n\n\nexclusive_minimum\n - \nTrue\n for an exclusive minimum limit. Defaults to \nFalse\n.\n\n\nmultiple_of\n - An integer that the data must be strictly divisible by, in order to be valid.\n\n\nenum\n - A list of valid numbers that the input must match against.\n\n\nallow_null\n - Indicates if \nNone\n should be considered a valid value. Defaults to \nFalse\n.\n\n\n\n\nBoolean\n\n\nValidates boolean input.\n\n\n\n\ndefault\n - A default to be used if a field using this typesystem is missing from a parent \nType\n.\n\n\ntitle\n - A title to use in API schemas and documentation.\n\n\ndescription\n - A description to use in API schemas and documentation.\n\n\nallow_null\n - Indicates if \nNone\n should be considered a valid value. Defaults to \nFalse\n.\n\n\n\n\nObject\n\n\nValidates dictionary input.\n\n\n\n\ndefault\n - A default to be used if a field using this typesystem is missing from a parent \nType\n.\n\n\ntitle\n - A title to use in API schemas and documentation.\n\n\ndescription\n - A description to use in API schemas and documentation.\n\n\nproperties\n - A dictionary mapping string key names to child validators.\n\n\npattern_properties\n - A dictionary mapping regex key names to child validators.\n\n\nadditional_properties\n - \nTrue\n if additional properties should be allowed. \nNone\n if additional properties should be discarded. \nFalse\n if additional properties should raise errors. Or a validator instance, to type check any additional properties against.\n\n\nmin_properties\n - An integer indicating the minimum number of properties that may be present. Defaults to \nNone\n.\n\n\nmax_properties\n - An integer indicating the maximum number of properties that may be present. Defaults to \nNone\n.\n\n\nrequired\n - A list of strings, indicating which properties are required.\n\n\nallow_null\n - Indicates if \nNone\n should be considered a valid value. Defaults to \nFalse\n.\n\n\n\n\nYou'll typically want to use the simpler declarative \nType\n style for\ndescribing dictionary inputs, but the \nObject\n validator may be useful if you\nneed more general purpose validation.\n\n\nArray\n\n\nValidates list input.\n\n\n\n\ndefault\n - A default to be used if a field using this typesystem is missing from a parent \nType\n.\n\n\ntitle\n - A title to use in API schemas and documentation.\n\n\ndescription\n - A description to use in API schemas and documentation.\n\n\nitems\n - A validator or a list of validators.\n\n\nadditional_items\n - Whether additional items past the end of the listed typesystem types are permitted.\n\n\nmin_items\n - The minimum number of items the array must contain.\n\n\nmax_items\n - The maximum number of items the array must contain.\n\n\nunique_items\n - Whether repeated items are permitted in the array.\n\n\ndescription\n - A description for online documentation\n\n\nallow_null\n - Indicates if \nNone\n should be considered a valid value. Defaults to \nFalse\n.\n\n\n\n\nFormats\n\n\nThe following validators return a native python representation, but can be serialized to strings.\n\n\nLet's declare a new type to see how they work...\n\n\nfrom apistar import types, validators\n\n\nclass Event(types.Type):\n    when = validators.DateTime()\n    description = validators.String(max_length=100)\n\n\n\n\nWhen accessed as attributes on a type, these validators return the native python value.\n\n\n data = {'when': '2021-06-15T12:31:38.269545', 'description': 'New customer signup'}\n\n event = Event(data)\n\n event.when\ndatetime.datetime(2021, 6, 15, 12, 31, 38, 269545)\n\n\n\n\nYou can also access the serialized string representation if needed.\n\n\n event['when']\n'2021-04-11T12:31:38.269545'\n\n dict(event)\n{'when': '2021-04-11T12:31:38.269545', 'description': 'New customer signup'}\n\n\n\n\nDate\n\n\n\n\ndefault\n - A default to be used if a field using this typesystem is missing from a parent \nType\n.\n\n\ntitle\n - A title to use in API schemas and documentation.\n\n\ndescription\n - A description to use in API schemas and documentation.\n\n\nallow_null\n - Indicates if \nNone\n should be considered a valid value. Defaults to \nFalse\n.\n\n\n\n\nTime\n\n\n\n\ndefault\n - A default to be used if a field using this typesystem is missing from a parent \nType\n.\n\n\ntitle\n - A title to use in API schemas and documentation.\n\n\ndescription\n - A description to use in API schemas and documentation.\n\n\nallow_null\n - Indicates if \nNone\n should be considered a valid value. Defaults to \nFalse\n.\n\n\n\n\nDateTime\n\n\n\n\ndefault\n - A default to be used if a field using this typesystem is missing from a parent \nType\n.\n\n\ntitle\n - A title to use in API schemas and documentation.\n\n\ndescription\n - A description to use in API schemas and documentation.\n\n\nallow_null\n - Indicates if \nNone\n should be considered a valid value. Defaults to \nFalse\n.", 
            "title": "The Type System"
        }, 
        {
            "location": "/api-guide/type-system/#type-system", 
            "text": "API Star comes with a type system that allows you to express constraints on the\nexpected inputs and outputs of your interface.  Here\u2019s a quick example of what the type system in API Star looks like:  from apistar import types, validators\n\n\nclass Product(types.Type):\n    name = validators.String(max_length=100)\n    rating = validators.Integer(minimum=1, maximum=5)\n    in_stock = validators.Boolean(default=False)\n    size = validators.String(enum=['small', 'medium', 'large'])  You can use the type system both for validation of incoming request data, and\nfor serializing outgoing response data.  Invalid data will result in a  ValidationError  being raised.   data = {'name': 't-shirt', 'size': 'big'}  product = Product(data)\napistar.exceptions.ValidationError: {'rating': 'This field is required.', 'size': 'Must be a valid choice.'}  Valid data will instantiate a new  Type  instance.   data = {'name': 't-shirt', 'rating': 4, 'size': 'large'}  product = Product(data) Product(name='t-shirt', rating=4, in_stock=False, size='large')   You can access the values on a  Type  instance as attributes.   product.name\n't-shirt'  Or treat a  Type  as a dictionary-like object.   product['rating']:\n4  dict(product)\n{'name': 't-shirt', 'rating': 4, 'in_stock': False, 'size': 'large'}", 
            "title": "Type System"
        }, 
        {
            "location": "/api-guide/type-system/#nested-types", 
            "text": "You can include  Type  classes as fields on other  Type  classes, like so:  class Location(types.Type):\n    latitude = validators.Number(maximum=90.0, minimum=-90.0)\n    longitude = validators.Number(maximum=180.0, minimum=-180.0)\n\n\nclass Event(types.Type):\n    location = Location\n    name = validators.String(max_length=100)", 
            "title": "Nested types"
        }, 
        {
            "location": "/api-guide/type-system/#validation", 
            "text": "You can use API Star  Type  classes as annotations inside your handler functions.  When you do so, validation will be handled automatically prior to running\nthe handler function. The type information will also be made available\nin the application's API Schema.  def create_product(product: Product):\n    # Save a new product record in the database.\n    ...\n\nroutes = [\n    Route('/create_product/', method='POST', handler=create_product)\n]", 
            "title": "Validation"
        }, 
        {
            "location": "/api-guide/type-system/#serialization", 
            "text": "You may also want to using the type system for data serialization,\nand include the type as a return annotation on handler functions.  Again, doing so will expose the type information to the application's\nAPI Schema, and will help ensure that the information your system\nreturns matches its documented return types.  import typing\n\n\ndef list_products() -  typing.List[Product]:\n    queryset = ...  # Query returning products from a data store.\n    return [Product(record) for record in queryset]", 
            "title": "Serialization"
        }, 
        {
            "location": "/api-guide/type-system/#including-additional-validation", 
            "text": "If you have validation rules that cannot be expressed with the default types,\nyou can include these by subclass the  __init__  method on the class.  This method should return the validated data, or raise a  ValidationError .  from apistar import exceptions, types, validators\n\n\nclass Organisation(types.Type):\n    is_premium = validators.Boolean()\n    expiry_date = validators.Date(allow_null=True)\n\n    def __init__(self, *args, **kwargs):\n        value = super().__init__(*args, **kwargs)\n        if value.is_premium and value.expiry_date is not None:\n            message = 'premium organisations should not have any expiry_date set.'\n            raise exceptions.ValidationError(message)\n        return value", 
            "title": "Including additional validation"
        }, 
        {
            "location": "/api-guide/type-system/#api-reference", 
            "text": "The following typesystem types are supported:", 
            "title": "API Reference"
        }, 
        {
            "location": "/api-guide/type-system/#string", 
            "text": "Validates string data.   default  - A default to be used if a field using this typesystem is missing from a parent  Type .  title  - A title to use in API schemas and documentation.  description  - A description to use in API schemas and documentation.  max_length  - A maximum valid length for the data.  min_length  - A minimum valid length for the data.  pattern  - A string value, giving a regular expression that the data must match.  enum  - A list of valid strings that the input must match against.  format  - An identifier indicating a complex datatype with a string representation. For example  \"date\" , to represent an ISO 8601 formatted date string.  allow_null  - Indicates if  None  should be considered a valid value. Defaults to  False .", 
            "title": "String"
        }, 
        {
            "location": "/api-guide/type-system/#number", 
            "text": "Validates numeric data.   default  - A default to be used if a field using this typesystem is missing from a parent  Type .  title  - A title to use in API schemas and documentation.  description  - A description to use in API schemas and documentation.  maximum  - A float representing the maximum valid value for the data.  minimum  - A float representing the minimum valid value for the data.  exclusive_maximum  -  True  for an exclusive maximum limit. Defaults to  False .  exclusive_minimum  -  True  for an exclusive minimum limit. Defaults to  False .  multiple_of  - A float that the data must be strictly divisible by, in order to be valid.  enum  - A list of valid numbers that the input must match against.  allow_null  - Indicates if  None  should be considered a valid value. Defaults to  False .", 
            "title": "Number"
        }, 
        {
            "location": "/api-guide/type-system/#integer", 
            "text": "Validates integer data.   default  - A default to be used if a field using this typesystem is missing from a parent  Type .  title  - A title to use in API schemas and documentation.  description  - A description to use in API schemas and documentation.  maximum  - An int representing the maximum valid value for the data.  minimum  - An int representing the minimum valid value for the data.  exclusive_maximum  -  True  for an exclusive maximum limit. Defaults to  False .  exclusive_minimum  -  True  for an exclusive minimum limit. Defaults to  False .  multiple_of  - An integer that the data must be strictly divisible by, in order to be valid.  enum  - A list of valid numbers that the input must match against.  allow_null  - Indicates if  None  should be considered a valid value. Defaults to  False .", 
            "title": "Integer"
        }, 
        {
            "location": "/api-guide/type-system/#boolean", 
            "text": "Validates boolean input.   default  - A default to be used if a field using this typesystem is missing from a parent  Type .  title  - A title to use in API schemas and documentation.  description  - A description to use in API schemas and documentation.  allow_null  - Indicates if  None  should be considered a valid value. Defaults to  False .", 
            "title": "Boolean"
        }, 
        {
            "location": "/api-guide/type-system/#object", 
            "text": "Validates dictionary input.   default  - A default to be used if a field using this typesystem is missing from a parent  Type .  title  - A title to use in API schemas and documentation.  description  - A description to use in API schemas and documentation.  properties  - A dictionary mapping string key names to child validators.  pattern_properties  - A dictionary mapping regex key names to child validators.  additional_properties  -  True  if additional properties should be allowed.  None  if additional properties should be discarded.  False  if additional properties should raise errors. Or a validator instance, to type check any additional properties against.  min_properties  - An integer indicating the minimum number of properties that may be present. Defaults to  None .  max_properties  - An integer indicating the maximum number of properties that may be present. Defaults to  None .  required  - A list of strings, indicating which properties are required.  allow_null  - Indicates if  None  should be considered a valid value. Defaults to  False .   You'll typically want to use the simpler declarative  Type  style for\ndescribing dictionary inputs, but the  Object  validator may be useful if you\nneed more general purpose validation.", 
            "title": "Object"
        }, 
        {
            "location": "/api-guide/type-system/#array", 
            "text": "Validates list input.   default  - A default to be used if a field using this typesystem is missing from a parent  Type .  title  - A title to use in API schemas and documentation.  description  - A description to use in API schemas and documentation.  items  - A validator or a list of validators.  additional_items  - Whether additional items past the end of the listed typesystem types are permitted.  min_items  - The minimum number of items the array must contain.  max_items  - The maximum number of items the array must contain.  unique_items  - Whether repeated items are permitted in the array.  description  - A description for online documentation  allow_null  - Indicates if  None  should be considered a valid value. Defaults to  False .", 
            "title": "Array"
        }, 
        {
            "location": "/api-guide/type-system/#formats", 
            "text": "The following validators return a native python representation, but can be serialized to strings.  Let's declare a new type to see how they work...  from apistar import types, validators\n\n\nclass Event(types.Type):\n    when = validators.DateTime()\n    description = validators.String(max_length=100)  When accessed as attributes on a type, these validators return the native python value.   data = {'when': '2021-06-15T12:31:38.269545', 'description': 'New customer signup'}  event = Event(data)  event.when\ndatetime.datetime(2021, 6, 15, 12, 31, 38, 269545)  You can also access the serialized string representation if needed.   event['when']\n'2021-04-11T12:31:38.269545'  dict(event)\n{'when': '2021-04-11T12:31:38.269545', 'description': 'New customer signup'}", 
            "title": "Formats"
        }, 
        {
            "location": "/api-guide/type-system/#date", 
            "text": "default  - A default to be used if a field using this typesystem is missing from a parent  Type .  title  - A title to use in API schemas and documentation.  description  - A description to use in API schemas and documentation.  allow_null  - Indicates if  None  should be considered a valid value. Defaults to  False .", 
            "title": "Date"
        }, 
        {
            "location": "/api-guide/type-system/#time", 
            "text": "default  - A default to be used if a field using this typesystem is missing from a parent  Type .  title  - A title to use in API schemas and documentation.  description  - A description to use in API schemas and documentation.  allow_null  - Indicates if  None  should be considered a valid value. Defaults to  False .", 
            "title": "Time"
        }, 
        {
            "location": "/api-guide/type-system/#datetime", 
            "text": "default  - A default to be used if a field using this typesystem is missing from a parent  Type .  title  - A title to use in API schemas and documentation.  description  - A description to use in API schemas and documentation.  allow_null  - Indicates if  None  should be considered a valid value. Defaults to  False .", 
            "title": "DateTime"
        }, 
        {
            "location": "/api-guide/api-schemas/", 
            "text": "API Schemas\n\n\nBy default API Star will serve \nan Open API schema\n for your\napplication, at \n'/schema/'\n.\n\n\nLet's take a look at that with a short example...\n\n\nfrom apistar import App, Route\n\n\ndef welcome(name=None):\n    if name is None:\n        return {'message': 'Welcome to API Star!'}\n    return {'message': 'Welcome to API Star, %s!' % name}\n\nroutes = [\n    Route('/', method='GET', handler=welcome),\n]\n\napp = App(routes=routes)\n\n\nif __name__ == '__main__':\n    app.serve('127.0.0.1', 8080, use_debugger=True)\n\n\n\n\nStart the application running...\n\n\n$ python ./example.py\n * Running on http://127.0.0.1:8080/ (Press CTRL+C to quit)\n\n\n\n\nAnd download the schema...\n\n\n$ curl http://127.0.0.1:8080/schema/\n{\n    \nopenapi\n: \n3.0.0\n,\n    \ninfo\n: {\n        \ntitle\n: \n,\n        \ndescription\n: \n,\n        \nversion\n: \n\n    },\n    \npaths\n: {\n        \n/\n: {\n            \nget\n: {\n                \noperationId\n: \nwelcome\n,\n                \nparameters\n: [\n                    {\n                        \nname\n: \nname\n,\n                        \nin\n: \nquery\n\n                    }\n                ]\n            }\n        }\n    }\n}\n\n\n\n\nYou can disable the schema generation by using the \nschema_url\n argument.\n\n\napp = App(routes=routes, schema_url=None)", 
            "title": "API Schemas"
        }, 
        {
            "location": "/api-guide/api-schemas/#api-schemas", 
            "text": "By default API Star will serve  an Open API schema  for your\napplication, at  '/schema/' .  Let's take a look at that with a short example...  from apistar import App, Route\n\n\ndef welcome(name=None):\n    if name is None:\n        return {'message': 'Welcome to API Star!'}\n    return {'message': 'Welcome to API Star, %s!' % name}\n\nroutes = [\n    Route('/', method='GET', handler=welcome),\n]\n\napp = App(routes=routes)\n\n\nif __name__ == '__main__':\n    app.serve('127.0.0.1', 8080, use_debugger=True)  Start the application running...  $ python ./example.py\n * Running on http://127.0.0.1:8080/ (Press CTRL+C to quit)  And download the schema...  $ curl http://127.0.0.1:8080/schema/\n{\n     openapi :  3.0.0 ,\n     info : {\n         title :  ,\n         description :  ,\n         version :  \n    },\n     paths : {\n         / : {\n             get : {\n                 operationId :  welcome ,\n                 parameters : [\n                    {\n                         name :  name ,\n                         in :  query \n                    }\n                ]\n            }\n        }\n    }\n}  You can disable the schema generation by using the  schema_url  argument.  app = App(routes=routes, schema_url=None)", 
            "title": "API Schemas"
        }, 
        {
            "location": "/api-guide/event-hooks/", 
            "text": "Event Hooks\n\n\nSometimes you'll want to always run some code before or after a handler function.\n\n\nAPI Star provides something very similar to middleware, that lets you register\na group of functions to be run in response to particular events.\n\n\nHere's an example...\n\n\nclass CustomHeadersHook():\n    def on_response(self, response: http.Response):\n        response.headers['x-custom'] = 'Ran on_response()'\n\nevent_hooks = [CustomHeadersHook]\n\napp = App(routes=routes, event_hooks=event_hooks)\n\n\n\n\nAn event hook instance may include any or all of the following methods:\n\n\n\n\non_request(self, ...)\n - Runs before the handler function.\n\n\non_response(self, ...)\n - Runs after the handler function, or when a handled exception occurs.\n\n\non_error(self, ...)\n - Runs after any unhandled exception occurs.\n\n\n\n\nThe signature of the method may include any annotations that would be available\non a handler function, or the \nhttp.Response\n annotation.\n\n\nError handling\n\n\nSubclasses of \nHTTPException\n are dealt with by the applications exception handler,\nand return responses, that pass through any \non_response\n hooks as usual.\n\n\nUnhandled exceptions result in server errors, and should be treated differently.\nFor these cases, any installed \non_error\n event hooks will be run. This event hook\nallows you to monitor or log exceptions.\n\n\nIt's recommend that use of \non_error\n event hooks should be kept to a minimum,\ndealing only with whatever error monitoring is required.\n\n\nUsing event hooks\n\n\nEvent hooks can pull in components such as the request, the returned response,\nor the exception that resulted in a response. For example:\n\n\nclass ErrorHandlingHook:\n    def on_response(self, response: http.Response, exc: Exception):\n        if exc is None:\n            print(\nHandler returned a response\n)\n        else:\n            print(\nException handler returned a response\n)\n\n    def on_error(self, response: http.Response):\n        print(\nAn unhandled error was raised\n)\n\n\napp = App(routes=routes, event_hooks=[ErrorHandlingHook])\n\n\n\n\nEvent hooks are instantiated at the start of every request/response cycle, and can\nstore state between the request and response events.\n\n\nclass TimingHook:\n    def on_request(self):\n        self.started = time.time()\n\n    def on_response(self):\n        duration = time.time() - self.started\n        print(\nResponse returned in %0.6f seconds.\n % duration)\n\n\napp = App(routes=routes, event_hooks=[TimingHook])\n\n\n\n\nOrdering of event hooks\n\n\nThe \non_request\n hooks are run in the order that their classes are included.\n\n\nThe \non_response\n and \non_exception\n hooks are run in the reverse order that their classes are included.\n\n\nThis behaviour ensures that event hooks run in a similar manner to stack-based middleware,\nwith the each event hook wrapping everything that comes after it.", 
            "title": "Event Hooks"
        }, 
        {
            "location": "/api-guide/event-hooks/#event-hooks", 
            "text": "Sometimes you'll want to always run some code before or after a handler function.  API Star provides something very similar to middleware, that lets you register\na group of functions to be run in response to particular events.  Here's an example...  class CustomHeadersHook():\n    def on_response(self, response: http.Response):\n        response.headers['x-custom'] = 'Ran on_response()'\n\nevent_hooks = [CustomHeadersHook]\n\napp = App(routes=routes, event_hooks=event_hooks)  An event hook instance may include any or all of the following methods:   on_request(self, ...)  - Runs before the handler function.  on_response(self, ...)  - Runs after the handler function, or when a handled exception occurs.  on_error(self, ...)  - Runs after any unhandled exception occurs.   The signature of the method may include any annotations that would be available\non a handler function, or the  http.Response  annotation.", 
            "title": "Event Hooks"
        }, 
        {
            "location": "/api-guide/event-hooks/#error-handling", 
            "text": "Subclasses of  HTTPException  are dealt with by the applications exception handler,\nand return responses, that pass through any  on_response  hooks as usual.  Unhandled exceptions result in server errors, and should be treated differently.\nFor these cases, any installed  on_error  event hooks will be run. This event hook\nallows you to monitor or log exceptions.  It's recommend that use of  on_error  event hooks should be kept to a minimum,\ndealing only with whatever error monitoring is required.", 
            "title": "Error handling"
        }, 
        {
            "location": "/api-guide/event-hooks/#using-event-hooks", 
            "text": "Event hooks can pull in components such as the request, the returned response,\nor the exception that resulted in a response. For example:  class ErrorHandlingHook:\n    def on_response(self, response: http.Response, exc: Exception):\n        if exc is None:\n            print( Handler returned a response )\n        else:\n            print( Exception handler returned a response )\n\n    def on_error(self, response: http.Response):\n        print( An unhandled error was raised )\n\n\napp = App(routes=routes, event_hooks=[ErrorHandlingHook])  Event hooks are instantiated at the start of every request/response cycle, and can\nstore state between the request and response events.  class TimingHook:\n    def on_request(self):\n        self.started = time.time()\n\n    def on_response(self):\n        duration = time.time() - self.started\n        print( Response returned in %0.6f seconds.  % duration)\n\n\napp = App(routes=routes, event_hooks=[TimingHook])", 
            "title": "Using event hooks"
        }, 
        {
            "location": "/api-guide/event-hooks/#ordering-of-event-hooks", 
            "text": "The  on_request  hooks are run in the order that their classes are included.  The  on_response  and  on_exception  hooks are run in the reverse order that their classes are included.  This behaviour ensures that event hooks run in a similar manner to stack-based middleware,\nwith the each event hook wrapping everything that comes after it.", 
            "title": "Ordering of event hooks"
        }, 
        {
            "location": "/api-guide/dependency-injection/", 
            "text": "Dependency Injection\n\n\nAPI Star allows you to include various parameters on handler functions and\nevent hooks, and will automatically provide those parameters as required.\n\n\nYou can add additional components, making them available to handler functions\nif they are included in an annotation.\n\n\nHere's an example that makes the \nUser\n annotation available to handler functions.\n\n\nfrom apistar import App, Route, exceptions, http\nfrom apistar.server.components import Component\n\n\nclass User(object):\n    def __init__(self, username: str):\n        self.username = username\n\n\nclass UserComponent(Component):\n    def resolve(authorization: http.Header) -\n User:\n        \n\n        Determine the user associated with a request, using HTTP Basic Authentication.\n        \n\n        if authorization is None:\n            return None\n\n        scheme, token = authorization.split()\n        if scheme.lower() != 'basic':\n            return None\n\n        username, password = base64.b64decode(token).decode('utf-8').split(':')\n        if not self.check_authentication(username, password):\n            raise exceptions.Forbidden('Incorrect username or password.')\n\n        return User(username)\n\n    def check_authentication(self, username: str, password: str) -\n bool:\n        # Just an example here. You'd normally want to make a database lookup,\n        # and check against a hash of the password.\n        return password == 'secret'\n\n\ndef hello_user(user: User=None) -\n dict:\n    return {'hello': user.username if user else None}\n\n\nroutes = [\n    Route('/', method='GET', handler=hello_user)\n]\ncomponents = [UserComponent()]\n\napp = App(routes=routes, components=components)\n\n\n\n\nYou can combine components and event hooks in order to have a component\nthat always runs, regardless of if it is used in a handler function.\n\n\nclass MustBeAuthenticated():\n    def on_request(self, user: User=None) -\n None:\n        if user is None:\n            raise exceptions.NotAuthenticated()\n\n\ndef hello_user(user: User) -\n dict:\n    return {'hello': user.username}\n\n\nroutes = [\n    Route('/', method='GET', handler=hello_user)\n]\ncomponents = [UserComponent()]\nevent_hooks = [MustBeAuthenticated()]\n\napp = App(routes=routes, components=components, event_hooks=event_hooks)\n\n\n\n\nReference\n\n\nThe following components are already installed by default.\n\n\n\n\n\n\n\n\nClass\n\n\nNotes\n\n\n\n\n\n\n\n\n\n\nhttp.Method\n\n\nThe http method, as an uppercased string.\n\n\n\n\n\n\nhttp.URL\n\n\nThe full request URL, as a string-like object.\n\n\n\n\n\n\nhttp.Scheme\n\n\nThe scheme, either \nhttp\n or \nhttps\n.\n\n\n\n\n\n\nhttp.Host\n\n\nThe server hostname, as a string.\n\n\n\n\n\n\nhttp.Port\n\n\nThe server port, as an integer.\n\n\n\n\n\n\nhttp.Path\n\n\nThe URL path, excluding any querystring.\n\n\n\n\n\n\nhttp.QueryString\n\n\nThe querystring from the URL. eg. \"color=red\nsize=medium\".\n\n\n\n\n\n\nhttp.QueryParam\n\n\nA single query parameter, looked up against the parameter name.\n\n\n\n\n\n\nhttp.Headers\n\n\nA multidict\n\n\n\n\n\n\nhttp.Header\n\n\nA single query parameter, looked up against the parameter name.\n\n\n\n\n\n\nhttp.Body\n\n\nThe request body, as a bytestring.\n\n\n\n\n\n\nhttp.Request\n\n\nThe incoming request. Includes \nurl\n, \nmethod\n, \nheaders\n, and \nbody\n attributes.\n\n\n\n\n\n\nhttp.Response\n\n\nThe outgoing response. Only available to event hooks that run after the main handler function.\n\n\n\n\n\n\nhttp.PathParams\n\n\nThe matched path parameters for the incoming request.\n\n\n\n\n\n\nApp\n\n\nThe current application. Made available as \nApp\n for both multithreaded and async applications.\n\n\n\n\n\n\nRoute\n\n\nThe matched route for the incoming request.\n\n\n\n\n\n\nException\n\n\nNone\n unless exception handling is running.\n\n\n\n\n\n\nserver.wsgi.WSGIEnviron\n\n\nOnly for \nApp\n.\n\n\n\n\n\n\nserver.wsgi.WSGIStartResponse\n\n\nOnly for \nApp\n.\n\n\n\n\n\n\nserver.asgi.ASGIScope\n\n\nOnly for \nASyncApp\n.\n\n\n\n\n\n\nserver.asgi.ASGIReceive\n\n\nOnly for \nASyncApp\n.\n\n\n\n\n\n\nserver.asgi.ASGISend\n\n\nOnly for \nASyncApp\n.\n\n\n\n\n\n\nserver.components.ReturnValue\n\n\nUsed internally to access the return value of the preceeding function in a dependency injection chain.", 
            "title": "Dependency Injection"
        }, 
        {
            "location": "/api-guide/dependency-injection/#dependency-injection", 
            "text": "API Star allows you to include various parameters on handler functions and\nevent hooks, and will automatically provide those parameters as required.  You can add additional components, making them available to handler functions\nif they are included in an annotation.  Here's an example that makes the  User  annotation available to handler functions.  from apistar import App, Route, exceptions, http\nfrom apistar.server.components import Component\n\n\nclass User(object):\n    def __init__(self, username: str):\n        self.username = username\n\n\nclass UserComponent(Component):\n    def resolve(authorization: http.Header) -  User:\n         \n        Determine the user associated with a request, using HTTP Basic Authentication.\n         \n        if authorization is None:\n            return None\n\n        scheme, token = authorization.split()\n        if scheme.lower() != 'basic':\n            return None\n\n        username, password = base64.b64decode(token).decode('utf-8').split(':')\n        if not self.check_authentication(username, password):\n            raise exceptions.Forbidden('Incorrect username or password.')\n\n        return User(username)\n\n    def check_authentication(self, username: str, password: str) -  bool:\n        # Just an example here. You'd normally want to make a database lookup,\n        # and check against a hash of the password.\n        return password == 'secret'\n\n\ndef hello_user(user: User=None) -  dict:\n    return {'hello': user.username if user else None}\n\n\nroutes = [\n    Route('/', method='GET', handler=hello_user)\n]\ncomponents = [UserComponent()]\n\napp = App(routes=routes, components=components)  You can combine components and event hooks in order to have a component\nthat always runs, regardless of if it is used in a handler function.  class MustBeAuthenticated():\n    def on_request(self, user: User=None) -  None:\n        if user is None:\n            raise exceptions.NotAuthenticated()\n\n\ndef hello_user(user: User) -  dict:\n    return {'hello': user.username}\n\n\nroutes = [\n    Route('/', method='GET', handler=hello_user)\n]\ncomponents = [UserComponent()]\nevent_hooks = [MustBeAuthenticated()]\n\napp = App(routes=routes, components=components, event_hooks=event_hooks)", 
            "title": "Dependency Injection"
        }, 
        {
            "location": "/api-guide/dependency-injection/#reference", 
            "text": "The following components are already installed by default.     Class  Notes      http.Method  The http method, as an uppercased string.    http.URL  The full request URL, as a string-like object.    http.Scheme  The scheme, either  http  or  https .    http.Host  The server hostname, as a string.    http.Port  The server port, as an integer.    http.Path  The URL path, excluding any querystring.    http.QueryString  The querystring from the URL. eg. \"color=red size=medium\".    http.QueryParam  A single query parameter, looked up against the parameter name.    http.Headers  A multidict    http.Header  A single query parameter, looked up against the parameter name.    http.Body  The request body, as a bytestring.    http.Request  The incoming request. Includes  url ,  method ,  headers , and  body  attributes.    http.Response  The outgoing response. Only available to event hooks that run after the main handler function.    http.PathParams  The matched path parameters for the incoming request.    App  The current application. Made available as  App  for both multithreaded and async applications.    Route  The matched route for the incoming request.    Exception  None  unless exception handling is running.    server.wsgi.WSGIEnviron  Only for  App .    server.wsgi.WSGIStartResponse  Only for  App .    server.asgi.ASGIScope  Only for  ASyncApp .    server.asgi.ASGIReceive  Only for  ASyncApp .    server.asgi.ASGISend  Only for  ASyncApp .    server.components.ReturnValue  Used internally to access the return value of the preceeding function in a dependency injection chain.", 
            "title": "Reference"
        }, 
        {
            "location": "/api-guide/testing/", 
            "text": "Testing\n\n\nAPI Star isn't coupled to any particular testing framework.\n\n\nOne good option for writing your test cases is \nthe pytest framework\n.\n\n\nTo make it easier to run tests against your application, API Star includes\na test client, that acts as an adapter for the excellent python \nrequests\n\nlibrary, allowing you to make requests directly to your application.\n\n\nYou can use the API test client with \nany\n WSGI or ASGI application.\n\n\nfrom apistar import test\nfrom myproject import app\n\n\nclient = test.TestClient(app)\n\ndef test_hello_world():\n    response = client.get('/hello_world/')\n    assert response.status_code == 200\n    assert response.json() ==  {'hello': 'world'}", 
            "title": "Testing"
        }, 
        {
            "location": "/api-guide/testing/#testing", 
            "text": "API Star isn't coupled to any particular testing framework.  One good option for writing your test cases is  the pytest framework .  To make it easier to run tests against your application, API Star includes\na test client, that acts as an adapter for the excellent python  requests \nlibrary, allowing you to make requests directly to your application.  You can use the API test client with  any  WSGI or ASGI application.  from apistar import test\nfrom myproject import app\n\n\nclient = test.TestClient(app)\n\ndef test_hello_world():\n    response = client.get('/hello_world/')\n    assert response.status_code == 200\n    assert response.json() ==  {'hello': 'world'}", 
            "title": "Testing"
        }, 
        {
            "location": "/api-guide/deployment/", 
            "text": "Deployment\n\n\nThe Development Server\n\n\nYou'll want to make sure to include \napp.serve()\n in your main \napp.py\n module:\n\n\nif __name__ == '__main__':\n    app.serve('127.0.0.1', 5000, use_debugger=True, use_reloader=True)\n\n\n\n\nFor development you can now just run the application directly.\n\n\n$ python app.py\n * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)\n\n\n\n\nRunning in Production\n\n\nWhich webserver you use depends on if you're running \nApp\n or \nASyncApp\n.\n\n\nFor \nApp\n you can use any WSGI based webserver. Both \ngunicorn\n and \nuwsgi\n\nare good options.\n\n\nFor \nASyncApp\n you'll want to use an ASGI based webserver. Your options\nhere are \nuvicorn\n or \ndaphne\n.", 
            "title": "Deployment"
        }, 
        {
            "location": "/api-guide/deployment/#deployment", 
            "text": "", 
            "title": "Deployment"
        }, 
        {
            "location": "/api-guide/deployment/#the-development-server", 
            "text": "You'll want to make sure to include  app.serve()  in your main  app.py  module:  if __name__ == '__main__':\n    app.serve('127.0.0.1', 5000, use_debugger=True, use_reloader=True)  For development you can now just run the application directly.  $ python app.py\n * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)", 
            "title": "The Development Server"
        }, 
        {
            "location": "/api-guide/deployment/#running-in-production", 
            "text": "Which webserver you use depends on if you're running  App  or  ASyncApp .  For  App  you can use any WSGI based webserver. Both  gunicorn  and  uwsgi \nare good options.  For  ASyncApp  you'll want to use an ASGI based webserver. Your options\nhere are  uvicorn  or  daphne .", 
            "title": "Running in Production"
        }, 
        {
            "location": "/topics/release-notes/", 
            "text": "Release Notes\n\n\nVersion 0.5.x\n\n\n0.5.5\n\n\n\n\nFix nested types.\n\n\n\n\n0.5.4\n\n\n\n\nEvent hooks instantiated on each request/response cycle.\n\n\n\n\n0.5.3\n\n\n\n\nSupport multipart and urlencoded content in \nRequestData\n.\n\n\nReverse ordering of \non_response\n and \non_error\n event hooks.\n\n\n\n\n0.5.2\n\n\n\n\nGraceful handling of cases where \non_error\n handling raises errors.\n\n\n\n\n0.5.1\n\n\n\n\nFix for handlers than annotate \nResponse\n, not being available to the \nReturnValue\n annotation when \nrender_response\n is called.\n\n\n\n\n0.5\n\n\n\n\nShould have introduced a proper version bump, given the 0.4.5 changes.\n\n\n\n\nVersion 0.4.x\n\n\n0.4.5\n\n\n\n\non_response now runs for both regular reponses and handled exceptions.\n\n\non_error now only runs for unhandled exceptions (ie. 500 reponses).\n\n\nReturn 500 responses on error.\n\n\nTest client raises exceptions instead of returning 500 responses.\n\n\nAdd debug flag to app.serve(), to switch between debugger vs. plain responses.\n\n\nInclude \nhttp.QueryParam\n annotations in schema output, as one of the parameters.\n\n\nInclude handler docstring in schema output, as the 'description'.\n\n\nAllow subclassing of \ntype.Type\n.\n\n\n\n\n0.4.4\n\n\n\n\nOpenAPI schema uses \nrequestBody\n instead of the incorrect \nresponseBody\n.\n\n\nInclude \nhttp.Response\n component.\n\n\nDrop requirement of returning response from event hooks.\n\n\nUse \nshutil.move\n in preference to \nos.rename\n in \nDownloadCodec\n.\n\n\n\n\n0.4.3\n\n\n\n\nDrop erroneous commit.\n\n\n\n\n0.4.2\n\n\n\n\nMove \nRESPONSE_STATUS_TEXT\n out of \nhttp\n and into \nwsgi\n.\n\n\n\n\n0.4.1\n\n\n\n\nUpdate package info.\n\n\n\n\n0.4\n\n\nThe Version 0.4 release is a significant re-working of the API Star codebase.\nAs part of this there are a number of features that have been removed and not\nyet made their way back in to the project:\n\n\n\n\nThe API Docs have not yet been re-introduced.\n\n\nThe command routing has not yet been re-introduced.\n\n\nThe \napistar\n command line tool has not yet been re-introduced.\n\n\nThe ORM components have been removed. We'll be pushing for this kind of functionality to be addressed as third-party packages instead.\n\n\n\n\nHowever the overall state of the project is in a much better place than it\nwas in 0.3, and I'm confident that we've now got a great base to build on.\n\n\nWe've also gained a number of new features and improvements:\n\n\n\n\nASGI compatible. You'll be able to use either \nuvicorn\n or \ndaphne\n as servers for use with ASyncApp.\n\n\nOpenAPI is now the default schema representation.\n\n\nWe now have an event hooks API.\n\n\nThe dependency injection now has a much cleaner, simpler API and implementation.\n\n\nThe type system now has a much cleaner, simpler API and implementation.\n\n\nSettings are much cleaner, with each component configured at the point of instantiation, rather than one big global settings object that's available everywhere.\n\n\n\n\nIf you do need to continue working against the 0.3 version, you should refer\nto \nthe older documentation on GitHub\n. You should also make sure to serve any\nasync applications using uvicorn \n= 0.0.15, which uses the pre-ASGI interface style.", 
            "title": "Release Notes"
        }, 
        {
            "location": "/topics/release-notes/#release-notes", 
            "text": "", 
            "title": "Release Notes"
        }, 
        {
            "location": "/topics/release-notes/#version-05x", 
            "text": "", 
            "title": "Version 0.5.x"
        }, 
        {
            "location": "/topics/release-notes/#055", 
            "text": "Fix nested types.", 
            "title": "0.5.5"
        }, 
        {
            "location": "/topics/release-notes/#054", 
            "text": "Event hooks instantiated on each request/response cycle.", 
            "title": "0.5.4"
        }, 
        {
            "location": "/topics/release-notes/#053", 
            "text": "Support multipart and urlencoded content in  RequestData .  Reverse ordering of  on_response  and  on_error  event hooks.", 
            "title": "0.5.3"
        }, 
        {
            "location": "/topics/release-notes/#052", 
            "text": "Graceful handling of cases where  on_error  handling raises errors.", 
            "title": "0.5.2"
        }, 
        {
            "location": "/topics/release-notes/#051", 
            "text": "Fix for handlers than annotate  Response , not being available to the  ReturnValue  annotation when  render_response  is called.", 
            "title": "0.5.1"
        }, 
        {
            "location": "/topics/release-notes/#05", 
            "text": "Should have introduced a proper version bump, given the 0.4.5 changes.", 
            "title": "0.5"
        }, 
        {
            "location": "/topics/release-notes/#version-04x", 
            "text": "", 
            "title": "Version 0.4.x"
        }, 
        {
            "location": "/topics/release-notes/#045", 
            "text": "on_response now runs for both regular reponses and handled exceptions.  on_error now only runs for unhandled exceptions (ie. 500 reponses).  Return 500 responses on error.  Test client raises exceptions instead of returning 500 responses.  Add debug flag to app.serve(), to switch between debugger vs. plain responses.  Include  http.QueryParam  annotations in schema output, as one of the parameters.  Include handler docstring in schema output, as the 'description'.  Allow subclassing of  type.Type .", 
            "title": "0.4.5"
        }, 
        {
            "location": "/topics/release-notes/#044", 
            "text": "OpenAPI schema uses  requestBody  instead of the incorrect  responseBody .  Include  http.Response  component.  Drop requirement of returning response from event hooks.  Use  shutil.move  in preference to  os.rename  in  DownloadCodec .", 
            "title": "0.4.4"
        }, 
        {
            "location": "/topics/release-notes/#043", 
            "text": "Drop erroneous commit.", 
            "title": "0.4.3"
        }, 
        {
            "location": "/topics/release-notes/#042", 
            "text": "Move  RESPONSE_STATUS_TEXT  out of  http  and into  wsgi .", 
            "title": "0.4.2"
        }, 
        {
            "location": "/topics/release-notes/#041", 
            "text": "Update package info.", 
            "title": "0.4.1"
        }, 
        {
            "location": "/topics/release-notes/#04", 
            "text": "The Version 0.4 release is a significant re-working of the API Star codebase.\nAs part of this there are a number of features that have been removed and not\nyet made their way back in to the project:   The API Docs have not yet been re-introduced.  The command routing has not yet been re-introduced.  The  apistar  command line tool has not yet been re-introduced.  The ORM components have been removed. We'll be pushing for this kind of functionality to be addressed as third-party packages instead.   However the overall state of the project is in a much better place than it\nwas in 0.3, and I'm confident that we've now got a great base to build on.  We've also gained a number of new features and improvements:   ASGI compatible. You'll be able to use either  uvicorn  or  daphne  as servers for use with ASyncApp.  OpenAPI is now the default schema representation.  We now have an event hooks API.  The dependency injection now has a much cleaner, simpler API and implementation.  The type system now has a much cleaner, simpler API and implementation.  Settings are much cleaner, with each component configured at the point of instantiation, rather than one big global settings object that's available everywhere.   If you do need to continue working against the 0.3 version, you should refer\nto  the older documentation on GitHub . You should also make sure to serve any\nasync applications using uvicorn  = 0.0.15, which uses the pre-ASGI interface style.", 
            "title": "0.4"
        }
    ]
}