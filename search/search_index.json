{
    "docs": [
        {
            "location": "/",
            "text": "\ud83d\udee0 \nThe Web API toolkit.\n \ud83d\udee0\n\n\n\n\n\n\n\n    \n\n\n\n\n\n    \n\n\n\n\n\n    \n\n\n\n\n\n\n\n\n\nCommunity:\n \nhttps://discuss.apistar.org/\n \ud83e\udd14 \ud83d\udcad \ud83e\udd13 \ud83d\udcac \ud83d\ude0e\n\n\nRepository\n: \nhttps://github.com/encode/apistar\n \ud83d\udcbb\n\n\n\n\nAPI Star is a toolkit for working with OpenAPI or Swagger schemas. It allows you to:\n\n\n\n\nBuild API documentation, with a selection of available themes.\n\n\nValidate API schema documents, and provide contextual errors.\n\n\nValidate requests and responses, using the API Star type system.\n\n\nMake API requests using the dynamic client library.\n\n\n\n\nYou can use it to build static documentation, integrate it within a Web framework,\nor use it as the client library for interacting with other APIs.\n\n\nQuickstart\n\n\nInstall API Star:\n\n\n$ pip3 install apistar\n\n\n\n\nLet's take a look at some of the functionality the toolkit provides...\n\n\nWe'll start by creating an OpenAPI schema, \nschema.yaml\n:\n\n\nopenapi: 3.0.0\ninfo:\n  title: Widget API\n  version: '1.0'\n  description: An example API for widgets\nservers:\n  - url: https://www.example.org/\npaths:\n  /widgets:\n    get:\n      summary: List all the widgets.\n      operationId: listWidgets\n      parameters:\n      - in: query\n        name: search\n        description: Filter widgets by this search term.\n        schema:\n          type: string\n\n\n\n\nLet's also create a configuration file \napistar.yml\n:\n\n\nschema:\n  path: schema.yaml\n  format: openapi\n\n\n\n\nWe're now ready to start using the \napistar\n command line tool.\n\n\nWe can validate our OpenAPI schema:\n\n\n$ apistar validate\n\u2713 Valid OpenAPI schema.\n\n\n\n\nOr build developer documentation for our API:\n\n\n$ apistar docs --serve\n\u2713 Documentation available at \"http://127.0.0.1:8000/\" (Ctrl+C to quit)\n\n\n\n\nWe can also make API requests to the server referenced in the schema:\n\n\n$ apistar request listWidgets search=cogwheel\n\n\n\n\nWhere did the server go?\n\n\nWith version 0.6 onwards the API Star project is being focused as a\nframework-agnositic suite of API tooling. The plan is to build out this\nfunctionality in a way that makes it appropriate for use either as a stand-alone\ntool, or together with a large range of frameworks.\n\n\nThe 0.5 branch remains available on GitHub, and can be installed from PyPI\nwith \npip install apistar==0.5.41\n. Any further development of the API Star\nserver would likely need to be against a fork of that, under a new maintainer.\n\n\nIf you're looking for a high-performance Python-based async framework, then\nI would instead recommend \nStarlette\n.",
            "title": "Home"
        },
        {
            "location": "/#quickstart",
            "text": "Install API Star:  $ pip3 install apistar  Let's take a look at some of the functionality the toolkit provides...  We'll start by creating an OpenAPI schema,  schema.yaml :  openapi: 3.0.0\ninfo:\n  title: Widget API\n  version: '1.0'\n  description: An example API for widgets\nservers:\n  - url: https://www.example.org/\npaths:\n  /widgets:\n    get:\n      summary: List all the widgets.\n      operationId: listWidgets\n      parameters:\n      - in: query\n        name: search\n        description: Filter widgets by this search term.\n        schema:\n          type: string  Let's also create a configuration file  apistar.yml :  schema:\n  path: schema.yaml\n  format: openapi  We're now ready to start using the  apistar  command line tool.  We can validate our OpenAPI schema:  $ apistar validate\n\u2713 Valid OpenAPI schema.  Or build developer documentation for our API:  $ apistar docs --serve\n\u2713 Documentation available at \"http://127.0.0.1:8000/\" (Ctrl+C to quit)  We can also make API requests to the server referenced in the schema:  $ apistar request listWidgets search=cogwheel",
            "title": "Quickstart"
        },
        {
            "location": "/#where-did-the-server-go",
            "text": "With version 0.6 onwards the API Star project is being focused as a\nframework-agnositic suite of API tooling. The plan is to build out this\nfunctionality in a way that makes it appropriate for use either as a stand-alone\ntool, or together with a large range of frameworks.  The 0.5 branch remains available on GitHub, and can be installed from PyPI\nwith  pip install apistar==0.5.41 . Any further development of the API Star\nserver would likely need to be against a fork of that, under a new maintainer.  If you're looking for a high-performance Python-based async framework, then\nI would instead recommend  Starlette .",
            "title": "Where did the server go?"
        },
        {
            "location": "/schema-validation/",
            "text": "Schema validation\n\n\nYou can use API Star to validate your API Schema. When errors occur it'll\ngive you a full breakdown of exactly where the schema is incorrect.\n\n\n$ apistar validate --path schema.json --format openapi\n\u2713 Valid OpenAPI schema.\n\n\n\n\nConfiguration\n\n\nConfigure the defaults for \napistar validate\n using an \napistar.yml\n file.\n\n\nschema:\n    path: schema.json\n    format: openapi\n\n\n\n\nYou can now run the validation like so:\n\n\n$ apistar validate\n\u2713 Valid OpenAPI schema.\n\n\n\n\nProgrammatic interface\n\n\nYou can also run the schema validation programmatically:\n\n\nimport apistar\n\n\nschema = \"\"\"\nopenapi: 3.0.0\ninfo:\n  title: Widget API\n  version: '1.0'\n  description: An example API for widgets\npaths:\n  /widgets:\n    get:\n      summary: List all the widgets.\n      operationId: listWidgets\n      parameters:\n      - in: query\n        name: search\n        description: Filter widgets by this search term.\n        schema:\n          type: string\n\"\"\"\n\napistar.validate(schema, format='openapi', encoding=\"yaml\")\n\n\n\n\nFunction signature: \nvalidate(schema, format=None, encoding=None)\n\n\n\n\nschema\n - Either a dict representing the schema, or a string/bytestring.\n\n\nformat\n - One of \nopenapi\n, \nswagger\n, \njsonschema\n or \nconfig\n.\nIf unset, one of either \nopenapi\n or \nswagger\n will be inferred from the content if possible.\n\n\nencoding\n - If schema is passed as a string/bytestring then the encoding may be\nspecified as either \"json\" or \"yaml\".  If unset, it will be inferred from the content if possible.",
            "title": "Schema Validation"
        },
        {
            "location": "/schema-validation/#schema-validation",
            "text": "You can use API Star to validate your API Schema. When errors occur it'll\ngive you a full breakdown of exactly where the schema is incorrect.  $ apistar validate --path schema.json --format openapi\n\u2713 Valid OpenAPI schema.",
            "title": "Schema validation"
        },
        {
            "location": "/schema-validation/#configuration",
            "text": "Configure the defaults for  apistar validate  using an  apistar.yml  file.  schema:\n    path: schema.json\n    format: openapi  You can now run the validation like so:  $ apistar validate\n\u2713 Valid OpenAPI schema.",
            "title": "Configuration"
        },
        {
            "location": "/schema-validation/#programmatic-interface",
            "text": "You can also run the schema validation programmatically:  import apistar\n\n\nschema = \"\"\"\nopenapi: 3.0.0\ninfo:\n  title: Widget API\n  version: '1.0'\n  description: An example API for widgets\npaths:\n  /widgets:\n    get:\n      summary: List all the widgets.\n      operationId: listWidgets\n      parameters:\n      - in: query\n        name: search\n        description: Filter widgets by this search term.\n        schema:\n          type: string\n\"\"\"\n\napistar.validate(schema, format='openapi', encoding=\"yaml\")  Function signature:  validate(schema, format=None, encoding=None)   schema  - Either a dict representing the schema, or a string/bytestring.  format  - One of  openapi ,  swagger ,  jsonschema  or  config .\nIf unset, one of either  openapi  or  swagger  will be inferred from the content if possible.  encoding  - If schema is passed as a string/bytestring then the encoding may be\nspecified as either \"json\" or \"yaml\".  If unset, it will be inferred from the content if possible.",
            "title": "Programmatic interface"
        },
        {
            "location": "/api-documentation/",
            "text": "API Documentation\n\n\nAPI Star can build API documentation from an OpenAPI or Swagger schema.\nIt supports a number of different themes, and the command line tool allows you\nto preview the documentation as you edit the schema.\n\n\n$ apistar docs --path schema.json --format openapi`\n\u2713 Documentation built at \"build/index.html\".\n\n\n\n\nConfiguration\n\n\nConfigure the defaults for \napistar docs\n using an \napistar.yml\n file.\n\n\nschema:\n    path: schema.json\n    format: openapi\ndocs:\n    output_dir: docs\n    theme: apistar\n\n\n\n\nNow you can build the documentation like so:\n\n\n$ apistar docs\n\u2713 Documentation built at \"docs/index.html\".\n\n\n\n\nThe documentation is a static HTML build and can be hosted anywhere.\n\n\nPreviewing the API documentation\n\n\nTo preview the API documentation use \napistar docs --serve\n, which will\nbuild the documentation, and then start up a webserver.\n\n\n$ apistar docs --serve\n\u2713 Documentation available at \"http://127.0.0.1:8000/\" (Ctrl+C to quit)\n\n\n\n\nProgrammatic interface\n\n\nYou can also build API documentation using a programmatic interface.\nThis allows you to dynamically serve API documentation from any Python web\nserver that is able to generate an OpenAPI or Swagger specification.\n\n\nimport apistar\n\n\nschema = \"\"\"\nopenapi: 3.0.0\ninfo:\n  title: Widget API\n  version: '1.0'\n  description: An example API for widgets\npaths:\n  /widgets:\n    get:\n      summary: List all the widgets.\n      operationId: listWidgets\n      parameters:\n      - in: query\n        name: search\n        description: Filter widgets by this search term.\n        schema:\n          type: string\n\"\"\"\n\nindex_html = apistar.docs(schema, schema_url='/schema.yaml', static_url='/static/')\n\n\n\n\nIf you're serving the documentation dynamically, then you'll also need to make\nsure that your framework serves up the API schema, and the static media for the\ndocumentation theme.\n\n\nFunction signature: \ndocs(schema, format=None, encoding=None, theme=\"apistar\", schema_url=None, static_url=None)\n\n\n\n\nschema\n - Either a dict representing the schema, or a string/bytestring.\n\n\nformat\n - One of \n\"openapi\"\n or \n\"swagger\"\n. If unset, this will be inferred from the schema.\nIf unset, one of either \nopenapi\n or \nswagger\n will be inferred from the content if possible.\n\n\nencoding\n - If schema is passed as a string/bytestring then the encoding may be\nspecified as either \"json\" or \"yaml\". If not included, the encoding will be inferred from the content if possible.\n\n\ntheme\n - One of \n\"apistar\"\n, \n\"swaggerui\"\n, or \n\"redoc\"\n.\n\n\nschema_url\n - The URL for the schema file, as a string. Required for \nswaggerui\n and \nredoc\n.\n\n\nstatic_url\n - The prefix for the static files, as a string. For more complex cases, this can also\nbe passed as a function that takes a string path, and returns a string URL.",
            "title": "API Documentation"
        },
        {
            "location": "/api-documentation/#api-documentation",
            "text": "API Star can build API documentation from an OpenAPI or Swagger schema.\nIt supports a number of different themes, and the command line tool allows you\nto preview the documentation as you edit the schema.  $ apistar docs --path schema.json --format openapi`\n\u2713 Documentation built at \"build/index.html\".",
            "title": "API Documentation"
        },
        {
            "location": "/api-documentation/#configuration",
            "text": "Configure the defaults for  apistar docs  using an  apistar.yml  file.  schema:\n    path: schema.json\n    format: openapi\ndocs:\n    output_dir: docs\n    theme: apistar  Now you can build the documentation like so:  $ apistar docs\n\u2713 Documentation built at \"docs/index.html\".  The documentation is a static HTML build and can be hosted anywhere.",
            "title": "Configuration"
        },
        {
            "location": "/api-documentation/#previewing-the-api-documentation",
            "text": "To preview the API documentation use  apistar docs --serve , which will\nbuild the documentation, and then start up a webserver.  $ apistar docs --serve\n\u2713 Documentation available at \"http://127.0.0.1:8000/\" (Ctrl+C to quit)",
            "title": "Previewing the API documentation"
        },
        {
            "location": "/api-documentation/#programmatic-interface",
            "text": "You can also build API documentation using a programmatic interface.\nThis allows you to dynamically serve API documentation from any Python web\nserver that is able to generate an OpenAPI or Swagger specification.  import apistar\n\n\nschema = \"\"\"\nopenapi: 3.0.0\ninfo:\n  title: Widget API\n  version: '1.0'\n  description: An example API for widgets\npaths:\n  /widgets:\n    get:\n      summary: List all the widgets.\n      operationId: listWidgets\n      parameters:\n      - in: query\n        name: search\n        description: Filter widgets by this search term.\n        schema:\n          type: string\n\"\"\"\n\nindex_html = apistar.docs(schema, schema_url='/schema.yaml', static_url='/static/')  If you're serving the documentation dynamically, then you'll also need to make\nsure that your framework serves up the API schema, and the static media for the\ndocumentation theme.  Function signature:  docs(schema, format=None, encoding=None, theme=\"apistar\", schema_url=None, static_url=None)   schema  - Either a dict representing the schema, or a string/bytestring.  format  - One of  \"openapi\"  or  \"swagger\" . If unset, this will be inferred from the schema.\nIf unset, one of either  openapi  or  swagger  will be inferred from the content if possible.  encoding  - If schema is passed as a string/bytestring then the encoding may be\nspecified as either \"json\" or \"yaml\". If not included, the encoding will be inferred from the content if possible.  theme  - One of  \"apistar\" ,  \"swaggerui\" , or  \"redoc\" .  schema_url  - The URL for the schema file, as a string. Required for  swaggerui  and  redoc .  static_url  - The prefix for the static files, as a string. For more complex cases, this can also\nbe passed as a function that takes a string path, and returns a string URL.",
            "title": "Programmatic interface"
        },
        {
            "location": "/making-api-requests/",
            "text": "Making API requests\n\n\nThe APIStar client library allows you to make requests to an API, given an API Schema.\n\n\nHere's an example of how an API request might look:\n\n\n$ apistar request listWidgets search=cogwheel --path schema.yml\n[\n    {\n        \"name\": \"Small cogwheel.\",\n        \"productId\": 24325,\n        \"inStock\": true\n    },\n    {\n        \"name\": \"Large cogwheel.\",\n        \"productId\": 24326,\n        \"inStock\": true\n    }\n]\n\n\n\n\nConfiguration\n\n\nTo make an API request you'll normally want to make sure you have an\n\napistar.yml\n configuration file which references the API schema.\n\n\nThis will save you from having to include the schema path on every request.\n\n\nschema:\n    path: schema.yml\n    format: openapi\n\n\n\n\nWe can now make the request more simply, as:\n\n\n$ apistar request listWidgets search=cogwheel\n[\n    {\n        \"name\": \"Small cogwheel.\",\n        \"productId\": 24325,\n        \"inStock\": true\n    },\n    {\n        \"name\": \"Large cogwheel.\",\n        \"productId\": 24326,\n        \"inStock\": true\n    }\n]\n\n\n\n\nProgrammatic interface\n\n\nYou can make requests against an API using \nthe API Star client library\n.\n\n\nimport apistar\n\n\nschema = \"\"\"\nopenapi: 3.0.0\ninfo:\n  title: Widget API\n  version: '1.0'\n  description: An example API for widgets\npaths:\n  /widgets:\n    get:\n      summary: List all the widgets.\n      operationId: listWidgets\n      parameters:\n      - in: query\n        name: search\n        description: Filter widgets by this search term.\n        schema:\n          type: string\n\"\"\"\n\nclient = apistar.Client(schema, format='openapi', encoding=\"yaml\")\nresults = client.request('listWidgets', search=\"cogwheel\")\n\n\n\n\nSee \nthe client library documentation\n for more details.",
            "title": "Making API Requests"
        },
        {
            "location": "/making-api-requests/#making-api-requests",
            "text": "The APIStar client library allows you to make requests to an API, given an API Schema.  Here's an example of how an API request might look:  $ apistar request listWidgets search=cogwheel --path schema.yml\n[\n    {\n        \"name\": \"Small cogwheel.\",\n        \"productId\": 24325,\n        \"inStock\": true\n    },\n    {\n        \"name\": \"Large cogwheel.\",\n        \"productId\": 24326,\n        \"inStock\": true\n    }\n]",
            "title": "Making API requests"
        },
        {
            "location": "/making-api-requests/#configuration",
            "text": "To make an API request you'll normally want to make sure you have an apistar.yml  configuration file which references the API schema.  This will save you from having to include the schema path on every request.  schema:\n    path: schema.yml\n    format: openapi  We can now make the request more simply, as:  $ apistar request listWidgets search=cogwheel\n[\n    {\n        \"name\": \"Small cogwheel.\",\n        \"productId\": 24325,\n        \"inStock\": true\n    },\n    {\n        \"name\": \"Large cogwheel.\",\n        \"productId\": 24326,\n        \"inStock\": true\n    }\n]",
            "title": "Configuration"
        },
        {
            "location": "/making-api-requests/#programmatic-interface",
            "text": "You can make requests against an API using  the API Star client library .  import apistar\n\n\nschema = \"\"\"\nopenapi: 3.0.0\ninfo:\n  title: Widget API\n  version: '1.0'\n  description: An example API for widgets\npaths:\n  /widgets:\n    get:\n      summary: List all the widgets.\n      operationId: listWidgets\n      parameters:\n      - in: query\n        name: search\n        description: Filter widgets by this search term.\n        schema:\n          type: string\n\"\"\"\n\nclient = apistar.Client(schema, format='openapi', encoding=\"yaml\")\nresults = client.request('listWidgets', search=\"cogwheel\")  See  the client library documentation  for more details.",
            "title": "Programmatic interface"
        },
        {
            "location": "/client-library/",
            "text": "Client Library\n\n\nAPI Star includes a dynamic client library.\n\n\nTypically developers have had to build client libraries for each new\nAPI service, or auto-generate a new client on each new release.\n\n\nThe API Star dynamic client library works differently, in that it simply\ntakes the API schema as an argument when the client is instantiated,\nand then allows you to interact with the API.\n\n\nimport apistar\n\n\nschema = \"\"\"\nopenapi: 3.0.0\ninfo:\n  title: Widget API\n  version: '1.0'\n  description: An example API for widgets\npaths:\n  /widgets:\n    get:\n      summary: List all the widgets.\n      operationId: listWidgets\n      parameters:\n      - in: query\n        name: search\n        description: Filter widgets by this search term.\n        schema:\n          type: string\n\"\"\"\n\nclient = apistar.Client(schema)\nresult = client.request('listWidgets', search='cogwheel')\n\n\n\n\nInstantiating a client\n\n\nYou can instantiate an API client like so:\n\n\nimport apistar\n\nclient = apistar.Client(schema=...)\n\n\n\n\nSignature: \nClient(schema, format=None, encoding=None, auth=None, decoders=None, encoders=None, headers=None, session=None, allow_cookies=True)\n\n\n\n\nschema\n - An OpenAPI or Swagger schema. This can be passed either as a dict instance,\nor as a JSON or YAML encoded string/bytestring.\n\n\nformat\n - Either \"openapi\" or \"swagger\". You can leave this as None to have the\nschema format be automatically inferred.\n\n\nencoding\n - If passing the schema as a string/bytestring, this argument may\nbe used to specify either \n\"json\"\n or \n\"yaml\"\n.  If not included, the encoding will\nbe inferred from the content if possible.\n\n\nauth\n - Any authentication class to set on the request session.\n\n\ndecoders\n - Any decoders to enable for decoding the response content.\n\n\nencoders\n - Any encoders to enable for encoding the request content.\n\n\nheaders\n - A dictionary of custom headers to use on every request.\n\n\nsession\n - A requests \nSession\n instance to use for making the outgoing HTTP requests.\n\n\nallow_cookies\n - May be set to \nFalse\n to disable \nrequests\n standard cookie handling.\n\n\n\n\nMaking requests\n\n\nRequests to the API are made using the \nrequest\n method, including the operation id\nand any parameters.\n\n\nresult = client.request('listWidgets', search='cogwheel')\n\n\n\n\nThe \nresult\n will be a data structure, decoded appropriately from the response\ncontent, as determined by the \nContent-Type\n header of the response.\n\n\nIn the event of an error response (4xx or 5xx status codes) the client will\nraise \napistar.exceptions.ErrorResponse\n.\n\n\nThere are three attributes on here that you may wish to inspect:\n\n\n\n\n.title\n - A string indicating the response status code/phrase. Eg. \n\"400 Bad Request\"\n\n\n.status_code\n - An integer indicating the response status code. Eg. \n400\n\n\n.content - The decoded response content. Eg.\n{\"search\": \"Must be no more than 100 characters.\"}`\n\n\n\n\nIf the request is made with an incorrect set of parameters, or if the client\ncannot fulfil the request for some reason then \napistar.exceptions.ClientError\n\nwill be raised.\n\n\nAuthentication\n\n\nYou can use any standard \nrequests\n authentication class with the API client.\n\n\nimport apistar\nfrom requests.auth import HTTPDigestAuth\n\nschema = {...}\n\nauth = HTTPDigestAuth('user', 'pass')\nclient = apistar.Client(schema=schema, auth=auth)\n\n\n\n\nAPI Star also includes some authentication classes that you can use for making\nAPI requests.\n\n\n\n\napistar.client.auth.TokenAuthentication(token, scheme=\"Bearer\")\n - Allows token\nauthenticated HTTP requests, including an \nAuthorization: Bearer <token>\n header in\nall outgoing requests.\n\n\napistar.client.auth.SessionAuthentication(csrf_cookie_name, csrf_header_name)\n - Allows\nsession authenticated requests that are CSRF protected. The API will need to expose a login\noperation.\n\n\n\n\nDecoding responses\n\n\nThe return result is determined from the response by selecting a decoder based\non the response content-type header, and allowing it to decode the response content.\n\n\nBy default the client has the following decoders enabled:\n\n\n\n\napistar.client.decoders.JSONDecoder\n - Handles \napplication/json\n responses. The return result will be the decoded data structure.\n\n\napistar.client.decoders.TextDecoder\n - Matches \ntext/*\n, and handles any text responses. The return result will be a string.\n\n\napistar.client.decoders.DownloadDecoder\n - Matches \n*/*\n, and handles any other responses. The return result will be a temporary file, which will be deleted once closed or no longer referenced.\n\n\n\n\nYou can customize which decoders are installed on a client like so:\n\n\nclient = apistar.Client(schema, decoders=[JSONDecoder()])\n\n\n\n\nIn the example above the client would send \napplication/json\n in the \nAccept\n header,\nand would raise an error on any other content being returned.\n\n\nWriting a custom decoder\n\n\nTo write a custom decoder you should subclass \napistar.client.decoders.BaseDecoder\n,\nand override the \nmedia_type\n attribute, and the \ndecode(self, response)\n method.\n\n\nFor example:\n\n\nfrom apistar.client.decoders import BaseDecoder\nimport csv\n\n\nclass CSVDecoder(BaseDecoder):\n    media_type = 'text/csv'\n\n    def decode(self, response):\n        lines = response.text.splitlines()\n        reader = csv.reader(lines, delimiter=',')\n        return [row for row in reader]\n\n\n\n\nEncoding requests\n\n\nThe request body is determined depending on the encoding used for the request.\n\n\nBy default the client has the following encoders enabled:\n\n\n\n\napistar.client.encoders.JSONEncoder\n - Handles \napplication/json\n requests.\n\n\napistar.client.encoders.MultiPartEncoder\n - Handles \nmultipart/form-data\n requests.\n\n\napistar.client.encoders.URLEncodedEncoder\n - Handles \napplication/x-www-form-urlencoded\n requests.\n\n\n\n\nYou can customize which decoders are installed on a client like so:\n\n\nclient = apistar.Client(schema, encoders=[JSONEncoder()])\n\n\n\n\nIn the example above the client would send \napplication/json\n in outgoing requests,\nand would raise an error for requests which required any other encoding to be used.\n\n\nWriting a custom encoder\n\n\nTypically the default set of encoders will be appropriate for handling the\nencoding of the request body, since JSON or either of the types of form data\nare by far the most commonly used encodings for HTTP requests. However you can\ncustomize this behaviour if needed, in order to support endpoints which expect\nsome other type of encoding.\n\n\nTo write a custom encoded you should subclass \napistar.client.encoders.BaseEncoder\n,\nand override the \nmedia_type\n attribute, and the \nencode(self, options, content)\n method.\n\n\nThe \nencode\n method is used to modify the options that are passed to \nrequests.send(...)\n\nwhen making the outgoing request.\n\n\nFor example:\n\n\nfrom apistar.client.encoders import BaseEncoder\n\n\nclass TextEncoder(BaseDecoder):\n    media_type = 'text/plain'\n\n    def encode(self, options, content):\n        assert isinstance(content, str), 'The request body for this endpoint must be a string.'\n        options['headers']['content-type'] = 'text/plain'\n        options['data'] = content",
            "title": "Client Library"
        },
        {
            "location": "/client-library/#client-library",
            "text": "API Star includes a dynamic client library.  Typically developers have had to build client libraries for each new\nAPI service, or auto-generate a new client on each new release.  The API Star dynamic client library works differently, in that it simply\ntakes the API schema as an argument when the client is instantiated,\nand then allows you to interact with the API.  import apistar\n\n\nschema = \"\"\"\nopenapi: 3.0.0\ninfo:\n  title: Widget API\n  version: '1.0'\n  description: An example API for widgets\npaths:\n  /widgets:\n    get:\n      summary: List all the widgets.\n      operationId: listWidgets\n      parameters:\n      - in: query\n        name: search\n        description: Filter widgets by this search term.\n        schema:\n          type: string\n\"\"\"\n\nclient = apistar.Client(schema)\nresult = client.request('listWidgets', search='cogwheel')",
            "title": "Client Library"
        },
        {
            "location": "/client-library/#instantiating-a-client",
            "text": "You can instantiate an API client like so:  import apistar\n\nclient = apistar.Client(schema=...)  Signature:  Client(schema, format=None, encoding=None, auth=None, decoders=None, encoders=None, headers=None, session=None, allow_cookies=True)   schema  - An OpenAPI or Swagger schema. This can be passed either as a dict instance,\nor as a JSON or YAML encoded string/bytestring.  format  - Either \"openapi\" or \"swagger\". You can leave this as None to have the\nschema format be automatically inferred.  encoding  - If passing the schema as a string/bytestring, this argument may\nbe used to specify either  \"json\"  or  \"yaml\" .  If not included, the encoding will\nbe inferred from the content if possible.  auth  - Any authentication class to set on the request session.  decoders  - Any decoders to enable for decoding the response content.  encoders  - Any encoders to enable for encoding the request content.  headers  - A dictionary of custom headers to use on every request.  session  - A requests  Session  instance to use for making the outgoing HTTP requests.  allow_cookies  - May be set to  False  to disable  requests  standard cookie handling.",
            "title": "Instantiating a client"
        },
        {
            "location": "/client-library/#making-requests",
            "text": "Requests to the API are made using the  request  method, including the operation id\nand any parameters.  result = client.request('listWidgets', search='cogwheel')  The  result  will be a data structure, decoded appropriately from the response\ncontent, as determined by the  Content-Type  header of the response.  In the event of an error response (4xx or 5xx status codes) the client will\nraise  apistar.exceptions.ErrorResponse .  There are three attributes on here that you may wish to inspect:   .title  - A string indicating the response status code/phrase. Eg.  \"400 Bad Request\"  .status_code  - An integer indicating the response status code. Eg.  400  .content - The decoded response content. Eg. {\"search\": \"Must be no more than 100 characters.\"}`   If the request is made with an incorrect set of parameters, or if the client\ncannot fulfil the request for some reason then  apistar.exceptions.ClientError \nwill be raised.",
            "title": "Making requests"
        },
        {
            "location": "/client-library/#authentication",
            "text": "You can use any standard  requests  authentication class with the API client.  import apistar\nfrom requests.auth import HTTPDigestAuth\n\nschema = {...}\n\nauth = HTTPDigestAuth('user', 'pass')\nclient = apistar.Client(schema=schema, auth=auth)  API Star also includes some authentication classes that you can use for making\nAPI requests.   apistar.client.auth.TokenAuthentication(token, scheme=\"Bearer\")  - Allows token\nauthenticated HTTP requests, including an  Authorization: Bearer <token>  header in\nall outgoing requests.  apistar.client.auth.SessionAuthentication(csrf_cookie_name, csrf_header_name)  - Allows\nsession authenticated requests that are CSRF protected. The API will need to expose a login\noperation.",
            "title": "Authentication"
        },
        {
            "location": "/client-library/#decoding-responses",
            "text": "The return result is determined from the response by selecting a decoder based\non the response content-type header, and allowing it to decode the response content.  By default the client has the following decoders enabled:   apistar.client.decoders.JSONDecoder  - Handles  application/json  responses. The return result will be the decoded data structure.  apistar.client.decoders.TextDecoder  - Matches  text/* , and handles any text responses. The return result will be a string.  apistar.client.decoders.DownloadDecoder  - Matches  */* , and handles any other responses. The return result will be a temporary file, which will be deleted once closed or no longer referenced.   You can customize which decoders are installed on a client like so:  client = apistar.Client(schema, decoders=[JSONDecoder()])  In the example above the client would send  application/json  in the  Accept  header,\nand would raise an error on any other content being returned.",
            "title": "Decoding responses"
        },
        {
            "location": "/client-library/#writing-a-custom-decoder",
            "text": "To write a custom decoder you should subclass  apistar.client.decoders.BaseDecoder ,\nand override the  media_type  attribute, and the  decode(self, response)  method.  For example:  from apistar.client.decoders import BaseDecoder\nimport csv\n\n\nclass CSVDecoder(BaseDecoder):\n    media_type = 'text/csv'\n\n    def decode(self, response):\n        lines = response.text.splitlines()\n        reader = csv.reader(lines, delimiter=',')\n        return [row for row in reader]",
            "title": "Writing a custom decoder"
        },
        {
            "location": "/client-library/#encoding-requests",
            "text": "The request body is determined depending on the encoding used for the request.  By default the client has the following encoders enabled:   apistar.client.encoders.JSONEncoder  - Handles  application/json  requests.  apistar.client.encoders.MultiPartEncoder  - Handles  multipart/form-data  requests.  apistar.client.encoders.URLEncodedEncoder  - Handles  application/x-www-form-urlencoded  requests.   You can customize which decoders are installed on a client like so:  client = apistar.Client(schema, encoders=[JSONEncoder()])  In the example above the client would send  application/json  in outgoing requests,\nand would raise an error for requests which required any other encoding to be used.",
            "title": "Encoding requests"
        },
        {
            "location": "/client-library/#writing-a-custom-encoder",
            "text": "Typically the default set of encoders will be appropriate for handling the\nencoding of the request body, since JSON or either of the types of form data\nare by far the most commonly used encodings for HTTP requests. However you can\ncustomize this behaviour if needed, in order to support endpoints which expect\nsome other type of encoding.  To write a custom encoded you should subclass  apistar.client.encoders.BaseEncoder ,\nand override the  media_type  attribute, and the  encode(self, options, content)  method.  The  encode  method is used to modify the options that are passed to  requests.send(...) \nwhen making the outgoing request.  For example:  from apistar.client.encoders import BaseEncoder\n\n\nclass TextEncoder(BaseDecoder):\n    media_type = 'text/plain'\n\n    def encode(self, options, content):\n        assert isinstance(content, str), 'The request body for this endpoint must be a string.'\n        options['headers']['content-type'] = 'text/plain'\n        options['data'] = content",
            "title": "Writing a custom encoder"
        },
        {
            "location": "/type-system/",
            "text": "Type System\n\n\nAPI Star comes with a type system that allows you to express constraints on the\nexpected inputs and outputs of your interface.\n\n\nThe \nType\n class\n\n\nHere\u2019s a quick example of what the type system in API Star looks like:\n\n\nfrom apistar import types, validators\n\n\nclass Product(types.Type):\n    name = validators.String(max_length=100)\n    rating = validators.Integer(minimum=1, maximum=5)\n    in_stock = validators.Boolean(default=False)\n    size = validators.String(enum=['small', 'medium', 'large'])\n\n\n\n\nYou can use the type system both for validation of incoming request data, and\nfor serializing outgoing response data.\n\n\nInvalid data will result in a \nValidationError\n being raised.\n\n\n>>> data = {'name': 't-shirt', 'size': 'big'}\n>>> product = Product(data)\napistar.exceptions.ValidationError: {'rating': 'This field is required.', 'size': 'Must be a valid choice.'}\n\n\n\n\nValid data will instantiate a new \nType\n instance.\n\n\n>>> data = {'name': 't-shirt', 'rating': 4, 'size': 'large'}\n>>> product = Product(data)\n<Product(name='t-shirt', rating=4, in_stock=False, size='large')>\n\n\n\n\nYou can access the values on a \nType\n instance as attributes.\n\n\n>>> product.name\n't-shirt'\n\n\n\n\nOr treat a \nType\n as a dictionary-like object.\n\n\n>>> product['rating']:\n4\n>>> dict(product)\n{'name': 't-shirt', 'rating': 4, 'in_stock': False, 'size': 'large'}\n\n\n\n\nNested types\n\n\nYou can include \nType\n classes as fields on other \nType\n classes, like so:\n\n\nclass Location(types.Type):\n    latitude = validators.Number(maximum=90.0, minimum=-90.0)\n    longitude = validators.Number(maximum=180.0, minimum=-180.0)\n\n\nclass Event(types.Type):\n    location = Location\n    name = validators.String(max_length=100)\n\n\n\n\nAPI Reference\n\n\nThe following typesystem types are supported:\n\n\nString\n\n\nValidates string data.\n\n\n\n\ndefault\n - A default to be used if a field using this typesystem is missing from a parent \nType\n.\n\n\ntitle\n - A title to use in API schemas and documentation.\n\n\ndescription\n - A description to use in API schemas and documentation.\n\n\nmax_length\n - A maximum valid length for the data.\n\n\nmin_length\n - A minimum valid length for the data.\n\n\npattern\n - A string value, giving a regular expression that the data must match.\n\n\nenum\n - A list of valid strings that the input must match against.\n\n\nformat\n - An identifier indicating a complex datatype with a string representation. For example \n\"date\"\n, to represent an ISO 8601 formatted date string.\n\n\nallow_null\n - Indicates if \nNone\n should be considered a valid value. Defaults to \nFalse\n. If set to \nTrue\n and no default value is specified then default=\nNone\n will be used.\n\n\n\n\nNumber\n\n\nValidates numeric data.\n\n\n\n\ndefault\n - A default to be used if a field using this typesystem is missing from a parent \nType\n.\n\n\ntitle\n - A title to use in API schemas and documentation.\n\n\ndescription\n - A description to use in API schemas and documentation.\n\n\nmaximum\n - A float representing the maximum valid value for the data.\n\n\nminimum\n - A float representing the minimum valid value for the data.\n\n\nexclusive_maximum\n - \nTrue\n for an exclusive maximum limit. Defaults to \nFalse\n.\n\n\nexclusive_minimum\n - \nTrue\n for an exclusive minimum limit. Defaults to \nFalse\n.\n\n\nmultiple_of\n - A float that the data must be strictly divisible by, in order to be valid.\n\n\nenum\n - A list of valid numbers that the input must match against.\n\n\nallow_null\n - Indicates if \nNone\n should be considered a valid value. Defaults to \nFalse\n. If set to \nTrue\n and no default value is specified then default=\nNone\n will be used.\n\n\n\n\nInteger\n\n\nValidates integer data.\n\n\n\n\ndefault\n - A default to be used if a field using this typesystem is missing from a parent \nType\n.\n\n\ntitle\n - A title to use in API schemas and documentation.\n\n\ndescription\n - A description to use in API schemas and documentation.\n\n\nmaximum\n - An int representing the maximum valid value for the data.\n\n\nminimum\n - An int representing the minimum valid value for the data.\n\n\nexclusive_maximum\n - \nTrue\n for an exclusive maximum limit. Defaults to \nFalse\n.\n\n\nexclusive_minimum\n - \nTrue\n for an exclusive minimum limit. Defaults to \nFalse\n.\n\n\nmultiple_of\n - An integer that the data must be strictly divisible by, in order to be valid.\n\n\nenum\n - A list of valid numbers that the input must match against.\n\n\nallow_null\n - Indicates if \nNone\n should be considered a valid value. Defaults to \nFalse\n. If set to \nTrue\n and no default value is specified then default=\nNone\n will be used.\n\n\n\n\nBoolean\n\n\nValidates boolean input.\n\n\n\n\ndefault\n - A default to be used if a field using this typesystem is missing from a parent \nType\n.\n\n\ntitle\n - A title to use in API schemas and documentation.\n\n\ndescription\n - A description to use in API schemas and documentation.\n\n\nallow_null\n - Indicates if \nNone\n should be considered a valid value. Defaults to \nFalse\n. If set to \nTrue\n and no default value is specified then default=\nNone\n will be used.\n\n\n\n\nObject\n\n\nValidates dictionary input.\n\n\n\n\ndefault\n - A default to be used if a field using this typesystem is missing from a parent \nType\n.\n\n\ntitle\n - A title to use in API schemas and documentation.\n\n\ndescription\n - A description to use in API schemas and documentation.\n\n\nproperties\n - A dictionary mapping string key names to child validators.\n\n\npattern_properties\n - A dictionary mapping regex key names to child validators.\n\n\nadditional_properties\n - \nTrue\n if additional properties should be allowed. \nNone\n if additional properties should be discarded. \nFalse\n if additional properties should raise errors. Or a validator instance, to type check any additional properties against.\n\n\nmin_properties\n - An integer indicating the minimum number of properties that may be present. Defaults to \nNone\n.\n\n\nmax_properties\n - An integer indicating the maximum number of properties that may be present. Defaults to \nNone\n.\n\n\nrequired\n - A list of strings, indicating which properties are required.\n\n\nallow_null\n - Indicates if \nNone\n should be considered a valid value. Defaults to \nFalse\n. If set to \nTrue\n and no default value is specified then default=\nNone\n will be used.\n\n\n\n\nYou'll typically want to use the simpler declarative \nType\n style for\ndescribing dictionary inputs, but the \nObject\n validator may be useful if you\nneed more general purpose validation.\n\n\nArray\n\n\nValidates list input.\n\n\n\n\ndefault\n - A default to be used if a field using this typesystem is missing from a parent \nType\n.\n\n\ntitle\n - A title to use in API schemas and documentation.\n\n\ndescription\n - A description to use in API schemas and documentation.\n\n\nitems\n - A validator or a list of validators.\n\n\nadditional_items\n - Whether additional items past the end of the listed typesystem types are permitted.\n\n\nmin_items\n - The minimum number of items the array must contain.\n\n\nmax_items\n - The maximum number of items the array must contain.\n\n\nunique_items\n - Whether repeated items are permitted in the array.\n\n\nallow_null\n - Indicates if \nNone\n should be considered a valid value. Defaults to \nFalse\n. If set to \nTrue\n and no default value is specified then default=\nNone\n will be used.\n\n\n\n\nFormats\n\n\nThe following validators return a native python representation, but can be serialized to strings.\n\n\nLet's declare a new type to see how they work...\n\n\nfrom apistar import types, validators\n\n\nclass Event(types.Type):\n    when = validators.DateTime()\n    description = validators.String(max_length=100)\n\n\n\n\nWhen accessed as attributes on a type, these validators return the native python value.\n\n\n>>> data = {'when': '2021-06-15T12:31:38.269545', 'description': 'New customer signup'}\n>>> event = Event(data)\n>>> event.when\ndatetime.datetime(2021, 6, 15, 12, 31, 38, 269545)\n\n\n\n\nYou can also access the serialized string representation if needed.\n\n\n>>> event['when']\n'2021-04-11T12:31:38.269545'\n>>> dict(event)\n{'when': '2021-04-11T12:31:38.269545', 'description': 'New customer signup'}\n\n\n\n\nDate\n\n\n\n\ndefault\n - A default to be used if a field using this typesystem is missing from a parent \nType\n.\n\n\ntitle\n - A title to use in API schemas and documentation.\n\n\ndescription\n - A description to use in API schemas and documentation.\n\n\nallow_null\n - Indicates if \nNone\n should be considered a valid value. Defaults to \nFalse\n.\n\n\n\n\nTime\n\n\n\n\ndefault\n - A default to be used if a field using this typesystem is missing from a parent \nType\n.\n\n\ntitle\n - A title to use in API schemas and documentation.\n\n\ndescription\n - A description to use in API schemas and documentation.\n\n\nallow_null\n - Indicates if \nNone\n should be considered a valid value. Defaults to \nFalse\n.\n\n\n\n\nDateTime\n\n\n\n\ndefault\n - A default to be used if a field using this typesystem is missing from a parent \nType\n.\n\n\ntitle\n - A title to use in API schemas and documentation.\n\n\ndescription\n - A description to use in API schemas and documentation.\n\n\nallow_null\n - Indicates if \nNone\n should be considered a valid value. Defaults to \nFalse\n.",
            "title": "Type System"
        },
        {
            "location": "/type-system/#type-system",
            "text": "API Star comes with a type system that allows you to express constraints on the\nexpected inputs and outputs of your interface.",
            "title": "Type System"
        },
        {
            "location": "/type-system/#the-type-class",
            "text": "Here\u2019s a quick example of what the type system in API Star looks like:  from apistar import types, validators\n\n\nclass Product(types.Type):\n    name = validators.String(max_length=100)\n    rating = validators.Integer(minimum=1, maximum=5)\n    in_stock = validators.Boolean(default=False)\n    size = validators.String(enum=['small', 'medium', 'large'])  You can use the type system both for validation of incoming request data, and\nfor serializing outgoing response data.  Invalid data will result in a  ValidationError  being raised.  >>> data = {'name': 't-shirt', 'size': 'big'}\n>>> product = Product(data)\napistar.exceptions.ValidationError: {'rating': 'This field is required.', 'size': 'Must be a valid choice.'}  Valid data will instantiate a new  Type  instance.  >>> data = {'name': 't-shirt', 'rating': 4, 'size': 'large'}\n>>> product = Product(data)\n<Product(name='t-shirt', rating=4, in_stock=False, size='large')>  You can access the values on a  Type  instance as attributes.  >>> product.name\n't-shirt'  Or treat a  Type  as a dictionary-like object.  >>> product['rating']:\n4\n>>> dict(product)\n{'name': 't-shirt', 'rating': 4, 'in_stock': False, 'size': 'large'}",
            "title": "The Type class"
        },
        {
            "location": "/type-system/#nested-types",
            "text": "You can include  Type  classes as fields on other  Type  classes, like so:  class Location(types.Type):\n    latitude = validators.Number(maximum=90.0, minimum=-90.0)\n    longitude = validators.Number(maximum=180.0, minimum=-180.0)\n\n\nclass Event(types.Type):\n    location = Location\n    name = validators.String(max_length=100)",
            "title": "Nested types"
        },
        {
            "location": "/type-system/#api-reference",
            "text": "The following typesystem types are supported:",
            "title": "API Reference"
        },
        {
            "location": "/type-system/#string",
            "text": "Validates string data.   default  - A default to be used if a field using this typesystem is missing from a parent  Type .  title  - A title to use in API schemas and documentation.  description  - A description to use in API schemas and documentation.  max_length  - A maximum valid length for the data.  min_length  - A minimum valid length for the data.  pattern  - A string value, giving a regular expression that the data must match.  enum  - A list of valid strings that the input must match against.  format  - An identifier indicating a complex datatype with a string representation. For example  \"date\" , to represent an ISO 8601 formatted date string.  allow_null  - Indicates if  None  should be considered a valid value. Defaults to  False . If set to  True  and no default value is specified then default= None  will be used.",
            "title": "String"
        },
        {
            "location": "/type-system/#number",
            "text": "Validates numeric data.   default  - A default to be used if a field using this typesystem is missing from a parent  Type .  title  - A title to use in API schemas and documentation.  description  - A description to use in API schemas and documentation.  maximum  - A float representing the maximum valid value for the data.  minimum  - A float representing the minimum valid value for the data.  exclusive_maximum  -  True  for an exclusive maximum limit. Defaults to  False .  exclusive_minimum  -  True  for an exclusive minimum limit. Defaults to  False .  multiple_of  - A float that the data must be strictly divisible by, in order to be valid.  enum  - A list of valid numbers that the input must match against.  allow_null  - Indicates if  None  should be considered a valid value. Defaults to  False . If set to  True  and no default value is specified then default= None  will be used.",
            "title": "Number"
        },
        {
            "location": "/type-system/#integer",
            "text": "Validates integer data.   default  - A default to be used if a field using this typesystem is missing from a parent  Type .  title  - A title to use in API schemas and documentation.  description  - A description to use in API schemas and documentation.  maximum  - An int representing the maximum valid value for the data.  minimum  - An int representing the minimum valid value for the data.  exclusive_maximum  -  True  for an exclusive maximum limit. Defaults to  False .  exclusive_minimum  -  True  for an exclusive minimum limit. Defaults to  False .  multiple_of  - An integer that the data must be strictly divisible by, in order to be valid.  enum  - A list of valid numbers that the input must match against.  allow_null  - Indicates if  None  should be considered a valid value. Defaults to  False . If set to  True  and no default value is specified then default= None  will be used.",
            "title": "Integer"
        },
        {
            "location": "/type-system/#boolean",
            "text": "Validates boolean input.   default  - A default to be used if a field using this typesystem is missing from a parent  Type .  title  - A title to use in API schemas and documentation.  description  - A description to use in API schemas and documentation.  allow_null  - Indicates if  None  should be considered a valid value. Defaults to  False . If set to  True  and no default value is specified then default= None  will be used.",
            "title": "Boolean"
        },
        {
            "location": "/type-system/#object",
            "text": "Validates dictionary input.   default  - A default to be used if a field using this typesystem is missing from a parent  Type .  title  - A title to use in API schemas and documentation.  description  - A description to use in API schemas and documentation.  properties  - A dictionary mapping string key names to child validators.  pattern_properties  - A dictionary mapping regex key names to child validators.  additional_properties  -  True  if additional properties should be allowed.  None  if additional properties should be discarded.  False  if additional properties should raise errors. Or a validator instance, to type check any additional properties against.  min_properties  - An integer indicating the minimum number of properties that may be present. Defaults to  None .  max_properties  - An integer indicating the maximum number of properties that may be present. Defaults to  None .  required  - A list of strings, indicating which properties are required.  allow_null  - Indicates if  None  should be considered a valid value. Defaults to  False . If set to  True  and no default value is specified then default= None  will be used.   You'll typically want to use the simpler declarative  Type  style for\ndescribing dictionary inputs, but the  Object  validator may be useful if you\nneed more general purpose validation.",
            "title": "Object"
        },
        {
            "location": "/type-system/#array",
            "text": "Validates list input.   default  - A default to be used if a field using this typesystem is missing from a parent  Type .  title  - A title to use in API schemas and documentation.  description  - A description to use in API schemas and documentation.  items  - A validator or a list of validators.  additional_items  - Whether additional items past the end of the listed typesystem types are permitted.  min_items  - The minimum number of items the array must contain.  max_items  - The maximum number of items the array must contain.  unique_items  - Whether repeated items are permitted in the array.  allow_null  - Indicates if  None  should be considered a valid value. Defaults to  False . If set to  True  and no default value is specified then default= None  will be used.",
            "title": "Array"
        },
        {
            "location": "/type-system/#formats",
            "text": "The following validators return a native python representation, but can be serialized to strings.  Let's declare a new type to see how they work...  from apistar import types, validators\n\n\nclass Event(types.Type):\n    when = validators.DateTime()\n    description = validators.String(max_length=100)  When accessed as attributes on a type, these validators return the native python value.  >>> data = {'when': '2021-06-15T12:31:38.269545', 'description': 'New customer signup'}\n>>> event = Event(data)\n>>> event.when\ndatetime.datetime(2021, 6, 15, 12, 31, 38, 269545)  You can also access the serialized string representation if needed.  >>> event['when']\n'2021-04-11T12:31:38.269545'\n>>> dict(event)\n{'when': '2021-04-11T12:31:38.269545', 'description': 'New customer signup'}",
            "title": "Formats"
        },
        {
            "location": "/type-system/#date",
            "text": "default  - A default to be used if a field using this typesystem is missing from a parent  Type .  title  - A title to use in API schemas and documentation.  description  - A description to use in API schemas and documentation.  allow_null  - Indicates if  None  should be considered a valid value. Defaults to  False .",
            "title": "Date"
        },
        {
            "location": "/type-system/#time",
            "text": "default  - A default to be used if a field using this typesystem is missing from a parent  Type .  title  - A title to use in API schemas and documentation.  description  - A description to use in API schemas and documentation.  allow_null  - Indicates if  None  should be considered a valid value. Defaults to  False .",
            "title": "Time"
        },
        {
            "location": "/type-system/#datetime",
            "text": "default  - A default to be used if a field using this typesystem is missing from a parent  Type .  title  - A title to use in API schemas and documentation.  description  - A description to use in API schemas and documentation.  allow_null  - Indicates if  None  should be considered a valid value. Defaults to  False .",
            "title": "DateTime"
        }
    ]
}